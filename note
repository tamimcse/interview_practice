1. To include "match.h", need to use -lm to compile

2. In backtracking algorithms, the inner algorithm should not return anything. The inner algorithm should return the outout as input.

3. cmp in qsort():

int cmp (const void *a, const void *b)
{
  return *((int *)a) - *((int *)b);
}

3. qsort prototype: qsort(arr, len, sizeof(arr[0]), cmp);

I often forget which one come first, lenght or size of the element. Remember, length comes first.

4. When returning char *, note that char * should also include '\0'. So, when allocating it, allocate one character extra.

5. when assigning NULL to an element of char *, assign '\0' instead;

6. Note that, you need to include 'string.h' in order to use memcpy.

7. memcpy prototype: memcpy(void *dest, const void * src, size_t n);
   memset prototype: memset(void *str, int c, size_t n);

Note that, memset is good for setting character to a string, but not suitable for setting an integer to an integer array.

8. remember that there are sprintf () and scanf ().

9. ASCII table has 256 characxters

9. When dealing with equation with index, double check if your equation needs "- 1".

10. Remember what palindrome and anagram means. Two strings are anagrams if their character count of each character is same for the two string. For instance, eat, ate and tea are anagram. 

11. *returnColumnSizes[i] is not right . It should be (*returnColumnSizes)[i].

12. Adjacency matrix may look easier than adjacency list, but they are really not. So, don't try to use adjacency matrix because it's easier. Besides, adjacency matrix requires looping through each element to the matrix row which cause to exceed time limit for large matrix.

13. Sometimes, a problem can be solved using graph. But, it can be solved not using graph and the version is more efficient. 

14. Sometimes, a problem can be solved using graph. and should be solved using graph. But, not really creating graph data structure. Remember the "word search" problem. Apply DFS without creating the graph.

15. Instead of checking col < num_col - 1, check if col + 1 < num_col.

16. If you need visit array for a 2D array (each element of the array is a node), create a 2D visit array, instead of a single array representing a 2D array. It produces cleaner code. (added later having single array is not bad either)

17. Think in terms of array length instead of index. This results clear code and easy to think of.

18. Instead of checking num_chars_grouped <= len - 2, check num_chars_grouped + 2 <= len.

19. For instance, you have two characters containing digits. Need to check if they corresponds to 1-26. You can check the first character and the  check if the second characters are within certain range. Instead, convert the string to its numerical value.

20. Sometimes, a problem may look like backtracking. Then look carefully if there is overlapping substructure. If there is, they can be optimized by memorization or even better can be implemented by DP. 

21. We can create zig zag pattern using two stacks.

22. Check if you can use a fixed number for stack or queue. If yes, alllocate it statically instead of dynamicly. But, implementing dynamically works fine in case you need to expand it.. (let's do that by default)

23. In min heap, each node is smaller than its chieldren. Index to the children can be found as:

                           idx1 = 2 * i + 1;//same as chield1 = 2n
                           idx2 = 2 * i + 2;//same as chield1 = 2n + 1

Again, to get the index of parent from a chield, use i = floor ((n - 1)/2); Can be implemented as i = (last_idx - 1) >> 1;

Note that, a heap is also a complete tree. A complete tree is where all the levels are completely filled except the last level. Example of banced tree is:


               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
     /  \   /
    8   7  9 

Complete tree is different from balanced tree. A balanced tree is where difference between height of left subtree and right subtree is at most one for all the nodes in the tree. For instance, these are unbalanced trees:

          4
        /   \
       3     5
      /       \
     2         6 
    /           \
   1             7

       30
      /
     20
    /
   10
Example of balanced tree is:
       4
    /    \
   2      6
 /  \    /  \
1    3  5    7 

Now, how to remove element from min-heap? remove the root. Replace the root with the last element (right most leaf). Then push down the root to maintain the heap property (also known as heapify in coremen's book, it's called bubble down in Skiena's book).

How to insert a new node to the heap? Add the new node to the end of the array (make it right most leaf). Then push it up to restore the heap properties. It is known as bubble up in Skiena's book. This is not heapify. Note that, insertion needs push_up instead of push_down() needed in heap_delete().

In heapify, first compare the two chieldren. Find the smallest children. Then compare if the node is larger than the smallest children. If yes, swap them. Note that, there can be only one children. So, implement it properly.

Given an array, how to construct a heap from that? First, find the parent to the last element. Apply heapify (bubble down) for that element and all the prior element in bottom up fashion. No need to perform bubble up.

Take a look at kth_smallest_element.c and kth_largest_stream.c.

24. If you need to compare k elements at each step to get the largest or smallest element, use min or max heap. Remember merging of k linked list or arrays..

25. char* strchar (char *str, char c) returns pointer to the first occurance of c in the str. If c does not occur, then it returns NULL.
 
26. char* strstr(char *s, char *pattern) returns pointer to the first occurance of the string pattern in string s. If pattern does not occur, it returns NULL.

27. sscanf usage:

   int day, year;
   char weekday[20], month[20], dtm[100];
   strcpy( dtm, "Saturday March 25 1989" );
   sscanf( dtm, "%s %s %d  %d", weekday, month, &day, &year );
   printf("%s %d, %d = %s\n", month, day, year, weekday );

28. There is no function called isnum() or isnumeric(). There is however isdigit(char c); 

29. parsing multiple string from a string using sscanf can be tricky. For instance,

  char s[4][20];
  int count = sscanf (IP, "%s.%s.%s.%s", &s[0][0], &s[1][0], &s[2][0], &s[3][0]);

  here, &s[0][0] gets the whole IP string.  &s[1][0], &s[2][0], &s[3][0] get garbage value. So, parse the string manually instead. 

for instance, see the following function:

bool valid_ipv4 (char * IP)
{
  int i, j, k, sum, num_dot = 0;
  int len = strlen (IP);
  
  for (i = 0, j = 0; i <= len; i++) {
    if (IP[i] == '.' || IP[i] == '\0') {
      num_dot++;
      if (i - j > 3 || i == j)
        return false;
      if (i - j >= 2 && IP[j] == '0')
        return false;
      sum = 0;
      for (k = j; k < i; k++) {
        sum = sum * 10 + (IP[k] - '0');
      }
      if (sum > 255)
        return false;
      j = i + 1;
      continue;
    }
    if (!isdigit(IP[i]))
      return false;
  }
  
  return num_dot == 4;
}

30. To implement DFS using stack, keep these in mind. 

First off, your stack may need more elements than the number of nodes. So, make the stack size twice as big as the number of nodes.

Second, you need two colors to color the visit array, not one color. When insert the first element to the stack, don't color it. In while loop, get the top of the stack (don't pop it immediately). If the ToS is colored as 1 then pop it and color as 2 (marked as visited). Otherwise, color the node with 1 (on the path). Then push all the adjacent nodes. When pushing adjacent nodes, check if the nodes have been colored yet (with 1 or 2). If the node we are inserting is 1, it means a cycle. You may add it or not depending on the application. If the node you are inserting is colored 2, that means, it's already visited and removed from the stack before. No need to add it back to stack.

Note that, when you are popping from the stack, it means backtracking. You need to add add continue (I often forget this) so that it processes the next from the stack.

Course scadule Example:

struct edge {
  int v2;
  struct edge *next;
};

bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize){
  struct edge **adj_list = (struct edge **) calloc (numCourses, sizeof (*adj_list));
  int i, j, curr;
  struct edge *new_edge;
  int *in_degrees = (int *) calloc (numCourses, sizeof (*in_degrees));
  int *visit = (int *) calloc (numCourses, sizeof (*visit));
  int *stack = (int *) malloc (numCourses * 2 * sizeof (*stack));
  int s_idx;
  struct edge *runner;
  
  for (i = 0; i < prerequisitesSize; i++) {
    new_edge = (struct edge *) malloc (sizeof (*new_edge));
    new_edge->v2 = prerequisites[i][1];
    new_edge->next = adj_list[prerequisites[i][0]];
    adj_list[prerequisites[i][0]] = new_edge;
  }
  
  for (i = 0; i < prerequisitesSize; i++) {
    in_degrees[prerequisites[i][1]]++;
  }
  
  for (i = 0; i < numCourses; i++) {
    if (visit[i] == 2)
      continue;
    s_idx = 0;
    stack[s_idx++] = i;
    while (s_idx) {
      curr = stack[s_idx - 1];
      if (visit[curr] == 1) {
        s_idx--;
        visit[curr] = 2;
        continue;
      }
      visit[curr] = 1;
      runner = adj_list[curr];
      while (runner) {
        if (visit[runner->v2] == 1)
          return false;
        //not already visited
        if (visit[runner->v2] != 2)
          stack[s_idx++] = runner->v2;
        runner = runner->next;
      }
    }
  }
  return true;
}

Added later:

This is not always the case. In some cases, in DFS, you can just pop from the stack (like DFS). For instance, number-of-islands problem can be solved using that. This is the case when you do not need to keep track of backtracking. If you need to keep track of backtracking (i.e. do sometimething during back tracking), you cannot pop from the stack immedidiately.

Added later: 

One color is very ofen fine. Just use a visit array. When you visit a node and add all adjacent node, mark it as 1 in the visit array. So, you won't expand it later. Note that, you should not mark a node just after adding to the stack. You should mark it after visit it from the stack (i.e. expanding it). Now, when you get a node from stack and it is marked, it means you are backtracking. So, simply remove it from the stack and add continue (so that you don't proceed further).

Note that sometimes, you may need to implement real backtracking algorithm in DFS. For instance, all-paths-from-source-to-target problem. In that case, you need to implement real backtracking algorithm in DFS. Recall that, in backstracking, when you backtrack, you need to unset the previous state. IN the same way, we need to unset the visit array so that DFS + Backtracking will visit previously visited node again (THis is very very interesting!!!!).

31. For instance, you want to reverse each word in  a string. Here, you should iterate from 0 to strlen(s) + 1. If i-th character is a space or NULL, then reverse the string.

32. If you are asked need to reverse a string, note that, your pointer should be i = 0, j = strlen(s). Often I take j = strlen (s) + 1.

33. For instance, You need to remove leading and trailing spaces. You also need to remove extra spaces between words. you can do it by maintaining a state variable called ignore_space. Initially it should be true. If you get a character, make it false. Again if you get a space, make it true.

34. If you print each trhiplet of an array, it should be like:

  i : 0 to len - 3
    j : i + 1 to len - 2
      k : j + 1 to len - 1

Not, 

  i : 0 to len - 1
    j : i + 1 to len -1
      k : j + 1 to len - 1

34. isalpha() checks if a char is a-z A-Z

35. Sometiomes, a problem can be solve by using two pointers and swaping element... (for instance, Sort Array By Parity). But, the problem can be also solved by quicksort partition.

Quick sort partion does the same thing in an uniform way. It also uses two indices and a pivot (usually the last element). Surprisingly, the two indices, i = -1 and j = 0. Idea is we will iterate j: 0 to n-1. Everytime arr[j] < pivot, swap (arr[++i], arr[j++]). That is, i keeps track of the left most element to which a smaller element needs to be swapped to. Finally, swap (arr[++i], arr[pivot]).

In other word, partitioning is a single pointer approach. It iterates from the first element to the last but one element. During iteration, it keeps track of the index to which a smaller element should be swapped to (represented by i). 

For details, take a look at https://www.geeksforgeeks.org/quick-sort/ 

36. if (a & 1 == 0) will not work!!!!. It should be if ((a & 1) == 0)

37. isalpha() checks if a character is an alphabet

38. It is possible to use sizeof () to calculate the amount of memory a string is consuming. But, you may get wrong results sometimes. So, you strlen instead of sizeof () to calculate the memory size of a string.

https://stackoverflow.com/questions/18525272/getting-wrong-string-length

39. Sometimes you may want to implement a circular array (e.g. hit counter problem). Mapping an element to an index of an array can be tricky. For instance, you want to access i-th element (index starts from 1) where length of the array in len. You can do so by

idx = (i - 1) % len; Not idx = (i % len) - 1.

Also iterating circular array can be tricky. for instace, you want iterate from index "start" to "end".

It should be :

for (i = start; i != end; i = (i + 1) % len) {

}

Note how we are incrementing i.
Also note how we are checking if we reached to the end. Checking if i < len will not work because if start > end, then i needs to be increase to end, then become 0 and then reach the end.

Again, for instance, you have two index i and j. You want to check if (i == j - 1), i.e. if i is the preceding element of j. You cannot do it directly because arr[len-1] is the preceeding element of arr[len-1]. To check such case, you can do this:

if ((i + 1) % len == j)

Also note that, idx_new_elem > idx_last_inserted_elem + len. That is, you are rounding the whole array. So, you may want to store that last inserted element.

40. Don't update input parameters as local variable. Create your own. It is less error prone.

41. If you need to calculate sum or multiplication of int/float, check if you need "long long" (for int) or "double" (for float) to store it. Otherwise overflow happens. If you need long long or double, also change the expression to make sure that longlong or double is stored. For instance,

int a, b;
long long sum;

sum = (long long)a + b; 

42. To print long long, using %lld. To print unsigned long long, use %llu.

To print long, using %ld. To print unsigned long, use %lu.

43. In snake ladder problem, it will be easier to solve the problem by considering each cell a number rather than a row and column. This patterns hold for many cases. If you have a 2D array, think if you can treat each cell as number instead of row col.

Sometimes, number to row-column conversion can be simplified by using slightly differnet equation. For instance, you can do the following:

  row = num / 6;
  if (num % 6 == 0)
    row--;

This can be simplified to 

  row = (num - 1) / 6;

So, if you need a special condition, check if you can find a pattern where the speacial condition goes away.

Also note that you may need to revisit the equation later if the equation works for all the cases.

44. Sometimes, in DP, I make O(n^2) solution where I could make O(n) solution (for instance house robber 1 and 2). In DP, you should not need to look much further in the DP table. You should only need to look for few previous elements to calculate the new element. If you need to look all the previous elements, double check if you could formulate DP such that that is not needed.

Note that, there are two types of DP table we saw so far.

One DP table always stores the best solution so far. It calculates the next entry based on the best solution of the current entry.

Another DP table stores the best solution using the current node. In this case, to calculate the value of a new entry, we need to iterate all the previous entry to get the best solution.

45. Sometimes, a complex problem can be break into simpler problems. Then solve the simpler problem. For instance, break the circular array of house robber II problem into two linear arrays.


46. atoi () returns 0 if convertion is not sucessful. If it returns non-zero, then conversion was sucessfull. Note that we cannot convert "0" with atoi. We need to check that manually. Note that if you pass a string "2+1+3" to atoi(), it returns 2. So, don't use to check if a string is a number or not.

But, if you know that the string is a number and not 0, then you can use atoi(). protottype: int atoi(const char *str).

But, please don't use itoa()!! Use sprintf () instead.

47. Sometimes, you need to find all possible cases of something. You won't need backtracking. But, you can use divide and conquar to break the problem into smaller problems. Then combine the results. You can implement that using recursion. For instance, different-ways-to-add-parentheses problem.

48. abs() returns absolute value. not mod(). sqrt() calculates square root, not sqart().

49. Sometimes, in DFS and BFS, we also need to store level in a separate array than stack/queue.

50. For instance, you are given a position of a knite in chess (horse). There are 8 possible next moves of the knite. You can find all the possible next move manually by add 1/2/-1/-2... But, better approach is store those numbers in an array and calculate the next index uniformly. Example:

int nm [8][2] = {{2, 1}, {2, -1}, {-2, 1}, {-2, -1}, {1, 2}, {1, -2}, {-1, 2}, {-1, -2}};

Then add the corresponding element.

51. Sometimes, you may tend to use dynamic array to implement the visit array of DFS or BFS. But, don't do that. It causes TLE (lookup in o(n)). Figure out a way to implement array, 2D array or hash to implement the visit array so that lookup in O(1).

52. BFS does not always need queue. You may need to use heap (priority queue) instead. Specially, we need to use heap in BFS in case of A* search. Note that, in A* search, each node will also have a heuristic value. The value is calculated based on two functions: 1) How far it is from start node 2) How far it is from the destination node.

We pick up the node with the lowest heuristic value from the heap.

Note that, the heuristic functiuon can be manhatan distance (abs(x1-x2) + abs (y1-y2)) or euclidian distance (sqrt (pow (x1-x2, 2) + pow (y1-y2, 2))).
Manhantan distance is preferable if we only are allowed to go vertically or horizontally. If we are allowed to go diagonally, euclidean distance is prefereable.

Note, the Dijekstra is a special case for A* search (and BFS). Here, heuristic function only contains the distance from the start node (does not contain distance from that node to end node). In Dijekstra, we can also use a heap to extract the node with lowest weight. 


53. Sometimes, the size of the visited array of BFS/DFS or the size of the stack and queue can be inferred from the constraint. For instance, in minimum-knight-moves problem, contraint is |x| + |y| <= 300. Here, x, y are the target coordinate of the knight. From the constraint, we can assume that the size of the visit array would 605 x 605 (one for initial point. 302 in each way).

54. Sometimes greedy solution may be tempting. For instance, coin change problem. However, with few counter example, you will notice that the greedy solution will not work. Next solution would be recursion to compute all possible situation. In that, try to write a mathemetical equation on paper. This really helps. Note that, the equation may need to find minimum/maximum of an expression for all inputs. The recursion generally works because it explores all possible solution. But, the recursive solutions are exponential. So, try to solve this using DP. If the problem follows principle of optimality (i.e. soution is subproblem will be there in larger problem), you can use DP using the recursive equation. (I saw this pattern in several problem)

55. Note that in BST, you can use in order travarsal to find a predeccessor or successor of a node. You can also implement predeccessor and successor function directly. For predeccosor, go one step left, then go as much right as you can. For successor, go one step right, then go as much left as you can. Also note that in BST, we may solve a problem partially and not fully done yet. We may need to solve the same problem for other node (subtree) recursively...For instance, delete-node-in-a-bst problem. Note that, recursion here can be tricy. You are passing root of a subtree. The function will perform on the subtree and return the new root. So, you need merge the new root to the previous node. Like:
 
runner->right = deleteNode (runner->right, succ->val);

56. Note that calculating something is often more efficient than determining something. For instance, you need a list of square numbers (i.e. 1, 4, 9..) from 1 to n. I tend to solve this problem by iterating a loop from 1 to n and check if each number is a square number. This is very expensive. Rather count how many square numbers there would be (i.e. sqrt (n)) and the calculate them as 1^2, 2^2, 3^2 and so on.


57. Also note that, you cannot compare an int and float. You should consider using floar(), ceil() or using double instead. I am not sure how to do that yet. Have to look more.

58. Given two ranges: [x1:x2] and [y1:y2]. They overlap if x1 <= y2 && y1 <= x2. Yes! this is true!!!

https://stackoverflow.com/questions/3269434/whats-the-most-efficient-way-to-test-two-integer-ranges-for-overlap

https://stackoverflow.com/questions/325933/determine-whether-two-date-ranges-overlap/325964#325964

So, in summery, the ranges does not overlap if y1 > x2 || x1 > y2. So, they do not overlap if !(y1 > x2 || x1 > y2) is true.

According to, De Morgan's law, !(A  or B) = !A and !B. So, two interval will overlap if !(y1 > x2) && !(x1 > y2) is true. 
In other words, (y1 <= x2) && (x1 <= y2) is true.

Note that, here instead of checking if two intervals overlap can be very complicated. Here, we are checking if two interval does not overlap or not and that makes it way simpler.

Now, how would you find the intersection of two interval? The interval would be: start = max (x1, y1), end = min (x2, y2). Now, another way to check if two interval overlaps by checking if end >= start, if yes, they intersects. 

58. If you have interval or point, think in terms of [x1, x2] and [y1, y2]. This is easier to think about than [start1, end1] and [start2, end2]. I think, they are also easier than topleftx1, bottomrightx2, ....

59. Sometimes, you will see typical recursion (divide&conquar) is not sufficient. They generate same result twice. In that case, you need to divide the solution into two parts such that one part contains the actual solutiom and the other part is formulated in a way that repeatation is avoided. For instance, coin-change-2 problem. Try to write the recursion equation on paper. If you have an input array, also add the array in the eqation. For instance, you are given an array, arr of size m and an input n. The eqation should look like:

f(arr, m, n) = f (arr, m-1, n) + f (arr, m, n - arr[m-1])

Now, check if this can be implemeneted using DP. Note that, this may seem difficult to implement as DP because here there are two dimentions. In the left sub-part, n does not reduces, so how can you calculate value of f(arr, m, n) based on the f (arr, m-1, n)? The answer is: we need to implement DP in a different way here. First, we should assume that the length of array is 0. Then calculate the DP table. Then in the next iteration, we need to assume that length of array is 1, and update the DP array again. Then, assume that the length of array is 2 and update the DP again and so on...

https://www.geeksforgeeks.org/coin-change-dp-7/
https://leetcode.com/problems/coin-change-2/solution/

When you use DP, also write the equation on the paper. For instance, dp[i] = dp[i] + dp[i - dp[j]]; Note that, in each iteration, we are just consideing one more element (coin) than previous step. That one more element is dp[j] here.

60. Sometimes dealing with intervals, we can project start and endtime of the intervals into an array to calculate the number of overlap across different time (e.g. meeting-rooms-ii). 

61. Sometimes, problem will give you diffeerent interval and ask how many meeting rooms will you need to accomodate the interval. The problem may sound like backtracking or greedy approach (e.g. meeting-rooms-ii). But, if you think carefully, you will see that this is same as asking the maximum number of overlapping intervals.

62. Note that, sometimes the problem may seem and is very hard. You can always find the brutforce solution. That involves having several loop or recursion. For instance, maximum-profit-in-job-scheduling or weighted-job-scheduling problem.  
 
Now, always write the recursive equation on the paper!!!

Then check if this eqation can be implemented as DP. If yes, implement that. keep in mind that DP always works like magic. The code is simple. And it works!!! Have faith and don't panic :-) The code most of the time works in the first few attempts.

63. Sometimes, you cannot draw points using traditional X-Y axis. Sometimes, the element at position is not on the points rather they are on the space between two points. For instance, trapping-rain-water problem. In that case, you need to number the space between two poaints rather the points.

For instance, instead of doing:

----|------|-----|------|-------------
    1      2     3      4

Do this:

----|------|-----|------|-------------
 1      2     3      4

64. Note that, there are fmin(), fmax() that can calculate min/max, however they are in cmath header (C++)

65. char *strcat(char *dest, const char *src)

Here, it appends src to dest. Note that, dest has to be large enough to store the appended string. This is very similar to sprintf ();

I would use sprinf() instead. 

Here, is an examle of strcat().

   char src[50], dest[50];

   strcpy(src,  "This is source");
   strcpy(dest, "This is destination");

   strcat(dest, src);

   printf("Final destination string : |%s|", dest);

66. Always initialize a pointer/string if you are not sure if it will always be assigned before use. You may think that you will add it later if needed. But, doing it in the first place doesn't do any harm and saves a lot of debug time.

67. A catch!!!!!!!

This is fine..
 
sprintf (out, "%s %s", out, str);

This is not!!!

sprintf (out, "%s %s", str, out);

This will produce "str str"!!! You can use another string or use strcat..., but don't do that! Write the logic in a way that you pass out as the first parameter!!!!!

68. Sometimes, logic requires like (e.g. integer-to-english-words problem):

sprintf (out, "%s%s%s", empty ? "" : out, empty ? "" : " ", str);

This makes it complicated. Try to write the logic using if-else... Like..

  if (ten) {
    sprintf (out, "%s", ten_str);
    if (one) {
      sprintf (out, "%s %s", out, one_str);
    }
  } else {
    sprintf (out, "%s", one_str);
  }

69. Sometimes it's nice to write comment in code while coding...

    if (end)
      break;
    //Reverse nodes from runner1 to runner2
    runner2 = runner1->next;

70. When writting iterator for linked list, use runner1, runner2, runner3... in code, but write r1, r2, r3..on paper. Don't use names like prev_node or temp node...even though you are using them as temp (actually this is more of my habit..)

71. Sometime linked list problem get TLE because program  does not set the next of the last node to NULL. Remember to set the next of the last node to NULL.

72. Anytime, you need to check if the index is >= 0 or < arr_length, always check like idx + 1 < arr_len or idx - 1 >= 0. I tend to check with idx which makes it complicated!!!! Keep this in mind. You will do it even though you think you wont :-)

73. Sometimes, solving a problem in a human way is very complex. First step is to find an intuitation to solve the problem. Sometimes, going to solve the intuition can be very difficult. For instance, trapping-rain-water problem. Instead of solving the problem for the whole space, try to solve it for a point in the space. If we can do it, solving for the whole speace is just repeating for each point. So, if a problem looks too dificult, see if you can solve the problem for a point of the problem space.

74. Also note that sometimes, an equation can be simpler when you have min/max in your equation. For instance, in trapping-rain-water problem, you need to know the maximum to the left and maximum to the right. In reality, this is not the case. But,as we take minimum of the two, our equation is still valid. 

75. Sometimes, you may inclined to represent intervals as :

----|------|-----|------|-------------
 1      2     3      4

But, you shouldn't! You should represent it as:

----|------|-----|------|-------------
    1      2     3      4

76. Also note that, although an interval is represented as [x, y], it is really [x, y)

77. Remember that, in some case, in DFS, you may want to set visit to false again in case of backtracking. For instance, word-search.

78. Note that, in DFS, when adding adjacent nodes to the stack, check if they are already visited.

79. Sometimes, in DFS, before adding adjacent node to the stack, you can check if you really should add it. For instance, in word-search problem, you know the next letter you will be looking for. So, if the adjacent node is not the next letter, you don't really need to add it. 

Note that, this is same as performing DFS recursively like flood water problem (At each node, we make recursive call on adjacent node). If adjacent node is not the next expecting node, we don't need to make the call. Also node that, here, we pass the visit array as a function parameter or global array so that all the recursive call gets the latest value of the visit array (passing as parameter is preferable). 

80. Trie node:

struct trie_node {
  bool leaf;//not really a leaf. It should be end-of-word
  struct trie_node *child[26];
};

Note that, trie node may not need value, because select the index to the next node based on the value. The root of of trie is often empty. This is how a trie looks like:

           root
           / | \
         c/  |b \a
         /   |   \
       node node node
       / | \
     c/  |b \a
     /   |   \
  node node node

I very often forget the structure of Trie. I forget that I don't need to store anything in trie_node because I am storing the data in child.. I forget that here child is the most important thing. The child array length can vary. For instance, in case of maximum-xor-of-two-numbers-in-an-array problem, it's a binary trie. So, child size is 2. 

I often tempted to create a separate leaf struct and put it as an instance of trie_node!!!!!!!!!!!!!!!!!! Note that, this is not needed. Just having a bool to indicate that if the node is a leaf or not is enough!!!

Added later:
----------------

Sometimes, you may want to store the content of the leaf because the actual path value is not readily accessible. So, you can also store the left value along with leaf flag. The leaf value is only valid if leaf flag is true. I did that for maximum-xor-of-two-numbers-in-an-array problem.

Also note that, you will always have your root in trie. The root is not added dynamically. So, you can have root statically and then add other nodes dynamically as:

struct node root;  
memset (&root, 0, sizeof (struct node));


81. Sometimes, we may need to travarse tree/trie while performing DFS in another graph (e.g. word-search-ii). It is easier to merge the recursive solution of tree travarsal and DFS.
 
82. While visiting Trie, we also need an array that keeps track of the string of the corresponding node.

83. When copying output to res (pointer), make sure that they are allocated in memory. Sometimes, you may just want to return pointer. You don't need to allocate memory in that case.

84. Don't forget to check nengivate condition first and then continue or return. If you proceed, that means you find a positive case. This requires fewer nested indentation.

85. Don't use *ret_size because it may not initialized properly. Use your own res_cnt. Then update *ret_size.

86. When inserting multiple strings to a trie, don't create a node if it already exists. That's the point of trie. But, I often create node for each character in each string.

87. Merging the intervals by projecting them on an array is an efficient solution. But, if each interval is very large, this may not be a good solution. You may want to merge the intervals manually in that case. You want to sort the intervals by start time in that case.

https://www.geeksforgeeks.org/merging-intervals/

88. Some problems are conventionally known as DP. You can also implement via recursion with memoraziation. For intsnace, in word-break problem, you can encode a dictionary with a trie. But, Trie search may need to make recursive call on a subproblem when you reach a node that denotes end of a word. This is because this node may not a leaf. So, you may want look further. So, the psudocode is like:

call search for the rest of the subproblem. If it returns true, then return true. Otherwise, proceed to the child of the current node.

This recursive call many same subproblem when trie is like:

   root
    |
    |a
    |
   node
    |
    |a
    |
   node
    |
    |a
    |
   node

For instance, if input is aaab, it will call search function for aaab, aab, ab, a, b, b, ab...


https://www.geeksforgeeks.org/word-break-problem-dp-32/

https://www.geeksforgeeks.org/word-break-problem-trie-solution/

This problem can be solved using memorization. So, if you solve a problem once, save the result. This may look trivial.but don't do it!!!!!!!


Yes, don't do it!!!!!! Once you figure how to use recursion, try to figure DP. It's way ceasier. And way easier to implement!! Yes, it's way easier to implement!!! So, don't try to implement a DP problem with recursion!!!!! DP is way easier.

89. Sometimes, I may send different pointer when making recursive call. Like: 

trie_search (root, &s[i+1], mem);

Don't do it! Do this instead:

trie_search (root, s, i+1, mem);

90. Sometimes, you may be asked to produce all combination of something. You need to know that finding all combination of something requires you to identify something first. For instance, in word-break-ii, you are asked to find all the ways you can break a string according to a dictionary. To solve the problem, we can solve word-break first, then use that to find all the combinations.

Now, if you do this, it will be very overly complicated. I may think this way, but there is a better way. try to find algorithm in fresh mind.

Note that, when you are asked to find all combinations, it's generally backtracking algorithm. So, try to use backtracking...

Note that, backtracking can also be think of as recursion or DFS. Sometimes, you may have an array. You may think you need to implemenet DFS/BFS on the array, but, they can be implemented as recursion (aka DFS). For instance, word-break-ii

Now, note that, anytime you have a recursive solution, check if there is overlapping subproblems. This tend to be very expensive. If there can be overlapping subproblems, implemenet them using DP. Besides, DP is a lot more easier than implementing recursion. In recursion, you are taking a complex problem, and dividing into smaller problem (top-down). On the other hand, in DP, you are starting with a smaller problem, and solving the bigger problem with smaller problem (bottom-up). This tend to be way easier!!!!!!!!

91. When iterating a trie using runner, if you find a match, you should move the runner to the next node immediately because that's the actual node. Then you can check if that node denotes the end of a word.

92. If you want to create a substring from a string, you can use memcpy() or strncpy().

strncpy(char* dest, char* src, int n) is from <cstring>.

Also note that if you use memcpy(), be sure to add NULL manually.

93. Sometimes you may need list of string. You don't have vector in C. So, what you do is have large ***str_list. Allocate them dynamically and use them like an array. This is not much difficult to do compared to vector. Only problem is you need to be aware to pre-allocate as much memory as you might need.

94. It can be more convinient to try to solve a problem based on bottom up approach. This is actaully DP. This actually way easier. A lot complicated problem can become surprisingly simple if you think in bottom up approach. For instance, count-of-range-sum.. So, think bottom up!!!!!!

95. When DPing half of a 2D array in diagonal mannager, use row, col for index along with i. For instance,

  for (i = 1; i < numsSize; i++) {
    for (row = 0, col = i; col < numsSize; row++, col++) {
      idx = row * numsSize + col;
      dp[idx] = dp[idx - 1] + nums[col];
    }
  }

Here, we are filling top-right part of the matrix.

95. How a negative number is stored in computer? It's store in two's complement format. For instance, 4 = 100. -4 = 1111111...1100 (one's complement is 11..1011. two's complement is 11..1100)

Again, 20 = 10100. -20 = 111...01100. 

So, there are several lessons:

a. If a number starts with 1, it's a negative number.
b. Content of a positive and negative number may differ in more than just sign field (MSB).
c. If a number is power of two, it's positive and negative number will only differ in signfield (and 111)
d. You can unset the right-most set bit by n - (n & -n). This is used in Binary index tree to calculate index to the parent.

On a similar note, n & (n - 1) unsets right-most set bit.

https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/


So, basicly, two's complement store the same number

96. If you are asked to develop range sum, you should ask if the array is immutatble. If the array is immutatble, the create prefix sum. Then, you can calculate any range sum at O(1). 

But, if the array is not mutable, then you need to create Binary Index Tree (BIT). BIT supports range query and update at O (logn). You can also use merge sort to implement this. Merge sort is more efficient, i think.

97. Sometimes, it's ok to create an array that is 1 eleenet larger (1 based array) if that makes the logic simpler.

98. In merge sort, you can merge two arrays in place. This is more efficient. But, sometimes, you may need to implement additional logic. It's OK to use an extra array to merge two arrays and implement that logic if that make the logic simpler (counting the number of smaller elements to the right). 

99. Sometimes, itrating array forward to caluclate O(n) while iterating the array backwords needs O(1). For instance, merging two arrays to calculate the number of smaller elements to the right, iterating array from the right allows us to caluclate the number at O(1). 

100. In merge sort, you can pass a preallocated temp array so that you don't need to alloccate a new array in every recursive call. Also note that this can be more efficient way of merging because merging two sorted arrays in place is not linear while this is. 

101. Suppose you have two sorted arrays A and B. You need to find the number of pairs such that lower <= B[j] - A[i] <= upper. We came across this problem in count-of-range-sum problem. 

Here, we will maintain a variable lo which indicates the index to the first element B for which B[lo] - A[i] >= lower for an iteration. Note that lo is not initialized to 0 in each iteration. It rather starts from where it stopped in the last iteration. We can do this because A is sorted. So, elemements to the left of lo will produce even lower B[j] - A[i] for the next element of A.

Algorithm:

  lo = 0;
  for (i = 0; i < A_len; i++) {
    while (lo < B_len && B[lo] - A[i] < lower)
      lo++;
    for (j = lo; j < B_len; j++) {
      if (B[j] - A[i] <= upper)
        count++;
      else
        break;//Once we reach an element where difference is larger than the upper, no need to go further because the differtence will increase
    }
  }

102. Sometimes, long is not enough. You need long long specially when multiplying by 2.. Note that, you can compare an int and long long. So, when comparing two variables, both does not have to be the same type. 

Also keep in mind that changing variable type to long long from int does not help by itself. You also need to perform casting in the original operation. For instance:

tmp = (long long)nums[j] * 2;

103. Note that, left-shift and right shift of negative number is undefined. So, don't use them if the number can be negative. Instead multiply by 2 or 5 or use division.... (plain old)


104. You don't really need a temporary long long variable. You can just cast in-place and compare. For intance:

if ((long long)nums[hi] * 2 >= nums[i]) is fine!!!!

105. Suppose, in merge sort approach, you often need to compute something based on two sorted arrays. For instance, in reverse-pairs problem, you will have two sorted arrays A and B. You need to count the number of pairs for which B[j] * 2 > A[i].

You can do this by following code:

  int hi = end;//only need to initialize once. In next iteration, start from when we stopped 
  for (i = mid; i >= start; i--) {
    while (hi >= mid + 1 && (long long)nums[hi] * 2 >= nums[i])
      hi--;
    if (hi >= mid + 1)
      *count += (hi - mid);
  }

106. Sometime, we iterate from i: 1-n to move each element one step left and insert a new element. Note that if array size is 1, this loop will not enter at all. Need to keep in mind to write the moving logic

107. Sometimes, you will be asked if you can solve the problem without using a hash-map. One solution is to use the input array as hash. For instance. if an element is seen, you can make the corresponding (original) array element negative. Thus negative element will indicate if the number has been seen or not. For instance, find-all-numbers-disappeared-in-an-array problem.

108. Sometimes, don't be too quick to judge between stack or queue. Play a simulation. Sometimes, it seems you need a queue, but you really need a stack..

109. When grouping string or list, check that if need to sort them first. For instance, when making group of anagrams, you don't need to check strings with different lengths. So, sorting the string first helps!!!

110. Don't use itoa() to convert int to char*. Use sprintf () instead.

111. When sorting a 2D arry using qsort (), you need to pass the size of the pointer instead of the size of the internal array. For instance, 

  char **num_str = (char **) malloc (numsSize * sizeof (*num_str));
  for (i = 0; i < numsSize; i++) {
    num_str[i] = (char *) calloc (12, sizeof (char));
    sprintf (num_str[i], "%d", nums[i]);
  }

  The qsort should look like:

qsort (num_str, numsSize, sizeof (char *), cmp);

It should not look like!!!!:

qsort (num_str, numsSize, 12 * sizeof (char), cmp);

Also, in this case: the cmp will be passed char**. So, it should look like:

int cmp (const void *a, const void *b)
{
  int i, j;
  char *num1 = *((char **)a);
  char *num2 = *((char **)b);
 .......
}

Not :

int cmp (const void *a, const void *b)
{
  int i, j;
  char *num1 = (char *)a;
  char *num2 = (char *)b;
 .......
}

Keep this in mind about cmp:

int cmp(const void* p1, const void* p2);
Return value meaning
<0 The element pointed by p1 goes before the element pointed by p2
0  The element pointed by p1 is equivalent to the element pointed by p2
>0 The element pointed by p1 goes after the element pointed by p2



112. When comparing character, I often forget '' more specially if the character is a digit. For instance, do ch == '0', not ch == 0


113. Note that, strcpy () is strcpy (char *dst, char *src). It does not need size of the string like memcpy. I often add an extra parameter string len * sizeof (char) which is not right.

114. Sometimes, implementing a logic can be too complicated. We can make it simple by creating extra data structure and compare them. For instance, in largest-number problem, we have two strings: x and y and we need to determine if xy > yx..

One solution is two have two pointers one pointing x and another pointing y..At each iteration we compare the value of the pointer. If the values are not the same, we get our answer. When the first pointer reach the end of x, make it to point y. In the same way, when the second pointer reach the end of y, make it point to the x.... But, this logic can be still compilcated to decide which one is better.

Another simpler solution is to just create xy and yx string and compare them. 


The first approach is obviously better, but the second approach is simpler!

115. Binary Subtraction:
0 – 0 = 0
1 – 0 = 1
1 – 1 = 0
0 – 1 = 1 (Borrow 1)

1011 - 11
0100 - 4
-----------
0111 - 7

115. To return a negative of a variable, we can do this: "return -a;" No need to do "return a * -1;"

116. In do-while loop, I forget semicolon after while. It should be:

do {

} while ();

117. If you need to perform bitwise operation, the operand cannot be negative. Make them positive by abs() and handle negative and positive values separately.


118. I often get confused with Xor (^) operation. I feel like preceeding 0s of a number will produce preceeding 1s in the result. But, actually preceeding 0s creates preceeding 0s in the result because 0 ^ 0 = 0.

119. if (!head || !(head->next)) is fine. We don't need to write if (!head || (head && !(head->next)))

Right side of the || will only execute if !head is false 

120. Sometimes, it ,may seem that initiazing to sometihing to -1 makes more sense than initializing to 0. Think hard if this is really the case. I often find later that initializing to 0 is just fine and works even better. Implementation is often simpler.

On an another note, sometimes, it may seem that storing partial result - 1 is more convinient and then get the final result by partial result + 1. But, this is often unnecessary. In many cases, I found that storing the actual result is just fine.

121. When doing DFS, think if you need to visit a previously visited node again. It depends on the application. Sometimes, you may want to backtrack and visit a previously visited node. In that case, when backtracking, you need to set visit[node] = 0 while backtracking. 

If you don't want to visit a previously visited node again (e.g. course-schedule-ii problem), you may want to store visit[node] = 2 when visiting that node. Later, if you encounter visit[node] == 2, it means you already expanded and vsited and added to the result. If you encounter again, just skip this.

If you want to check cycle in DFS, when exapnding face (adding successors to stack), check if it's already visited; if yes, it's a cycle.

122. Sometimes, iterative implementation of DFS/BFS can be too difficult. You may consider recursive implementation. For instance, longest-increasing-path-in-a-matrix problem. I came across similar issues before.

Sometimes, iterative implementation is not adequete at all!!!! For instance, think about a situation where you need to make a decision based on different branches of DFS. For instance, in longest-increasing-path-in-a-matrix problem, we need to keep track of longest path originating from each node. That is, we need to handle multiple braches at each node and then make decision on the branches. Iterative solution will simply iterarte nodes of each brach one at a time. Although it can detect backtracking, but it's hard to track where we are staring to visit aother brach... Implementing longest-increasing-path-in-a-matrix in iterative mode is very hard to implement. On the other hand, it's switable to be implemented using recursive approach because recursive approach handle multiple branches separately and then process themm...

123. If your input is a matrix, don't use 1-D array for visit or string anything. It may seem convinient, but believe me, it will make the code look uglier later. Instead create a 2D matrix. It's also easy to implement and produces easier code.

124. Sometimes, you can solve a problem with recursion (like backtracking). You can also notice that you can solve the problem in bottom-up manner like DP. But, in that case, in each entry, you need to store 2^n values. This means that you are not actually reducing computation. Here, DP = Recursion. This is need to be done by recursion because you need to check all the combinations. Example of such problem is target-sum problem.

125. Sometimes, it may seem that constructing graph is the right choice because graph algorithm may need to access adjacent nodes which may noyt be readily avaiulable. In that case, you may wonder how do we map data to node. One way to do is, just use original data's index as node index. Don't worry about original data at all. Simply use data's index as node ID to create adjacency list. Note that, adjacent list can simply contain the index. And we can get the corresponding data from the index. One such example is word-ladder problem.

Now think really hard? Do you really need to construct a graph. Once you have a graph, you can access all the adjacent nodes usimng a simple for loop. That's all a graph does for you. You actually ran some sorts of for loop to create the adjacency list anyway. So, actually you don't really need to create the adjacency list anyway even though you think you do. You can simply iterate over the data to get the adjacent nodes.

Moral: You almnost never need to construct a graph data structure. Implement you graph algorithm on the data directly.

126. vector.size() can be used to iterate a vector. There is no vector.count(). Note that, there is also vector::capacity...

127. For instance, you are given bunch of intervals. You are asked to calculate free intervals. For instance: employee-free-time problem.

This can be solved by projecting all the intervals onto an array. But, not that this process is not cheap. Specually if an interval itself is very large. It can be more easy and efficient to handle intervals manually. For instance, you can sort sort the intervals by start time. Then keep track of end time you found so far. If next interval start time is larger than the current end time, we found a free time (simple!!)

128. I did numerous times, still worth reminding that to visit a 2-D array, it should be like:

for (i = 0; i < num_row; i++) {
  for (j = 0; j < num_col; j++) {

  }
} 

That is, iterate row first. Then iterate columns.

129. Sometimes, recursive formulation follows like edit distance. If I have two string s1 and s2. Their edit-distance d[i][j] indicates edit distance of first i characters of s1 and j characters of s2. The formula here is:

d[i][j] = d[i-1][j-1] if s1[i] == s2[j]
d[i][j] = min (d[i-1][j], d[i][j-1]) + 1 if s1[i] != s2[j]

Note that, we consume both characters only if both are same. If both are not same, we don't consume both. We keep one same, and consume other and do the opposite and then take minimum.

I think, this..but, above formulation is wrong!!!!!!!!!!!!!

It should be:

d[i][j] = min (d[i-1][j-1], d[i][j-1] + 1, d[i-1][j] + 1) if s1[i] == s2[j]
d[i][j] = min (d[i-1][j] + 1, d[i][j-1] + 1, d[i-1][j-1] + 1) if s1[i] != s2[j]

For details, take a look at edit-distance problem!!!

Another issue!!!

In edit distance, you need to measure assume that string can be empty. If you try to use m x n mattrix where m and n are lengths of the string, it will not work. you should consider empty string as well. So, the matrix should be m + 1 x n + 1.

Please see https://leetcode.com/problems/edit-distance/solution/

130. Common trick: If solution does not work for a complex input, find a minimal input for which the program also breaks

131. You are asked to design twitter (e.g. design-twitter problem). Here, user can follow and unfollow and post tweets. In user's feed, 10 latest tweets of this own who he is following ought to be shown. 

In this case, you can design it in two way:

a. Design a data structure where each user's feed is precaluclated.
b. Design a data structure where each user's tweet is store and feed is calculated at runtime.

Approach (a) may be tempting, but note that problem with that is, when a user unfollow someone, the feed has to be updated. So, we need to remove that followee's tweet from the feed. On top of that, you need to fill the empty spaces of the feed with tweets of his own or his followees.. In a word, it makes it very complicated to unfollow someone.

On the other hand, in approach (b), you simply need to store the tweets. The feed is calculated at runtime. So, unfollowing process is not comlicated at all.

131. For instance, you need to store 10 latest items. You can implement this using circular array, dequeueu or double linked list. Double linked list can be used as dequeue (i.e. insert to the front and remove from the end). BUt, you simply can store them as a list and always insert at the beginning. If you need to implement a dequeue, you can use double linked list. That way, you can delete from tail. 

132. Suppose, you have k sorted list. Now, you need to retrieve n smallest elements from there list. This is a very common problem appears within a problem. Common way to solve this is to have k pointers each pointing a list. In each iteration, we need to compare k elements where pointers are pointing. That's how we get the smallest element. We will increase the pointer with smallest element. THis solution will take o(nk).

There is better approach!!!!

Use heap of size k. Insert the first element of each list into the heap. Then in each iteration, extract the minimum from heap amd insert the next element from the list where the extracted element belong to. This approach requires, O(nlogk)

133. Sometimes, a problem may involve doing sometihing with even/odd index, but the problem does not say it explicitly. For instance, wiggle-sort. If there is some sorts of pattern, the problem can be solve using even/odd patterns. 

134. Sometimes, you may try to solve a problem by rearranging the elements. But, that will require O(n^2) and still may not be solvable. There may not be a predicatable results in interaative approach. In iterative approach, you may need to iterate forward and backword. They are not easy as sorting. Example of such proble include wiggle-sort and reorganize-string. 

The problem may become easier if you sort them. For instance, in case of wiggle-sort.

Sometimes, you don't really need order. In that case, a map of character with their count may help. For instance, reorganize-string problem.

135. A tree can be travarsed two ways. DFS and BFS. Pre-order, in-order, post-order travarsals are variants of DFS. Again, recursively calling a function on left and right subtree can be think of as preorder or in order travarsal. But, sometimes you may need to do BFS as well. For instance, you need to travarse level order. You can do that by BFS.

136. In wiggle sort (wave-like sort), you can simply sort an array and then the swap every two adjacent elements.

           4                     4 
       3                             3  
    2             ->       2     
 1                            1   

Now, note this this will not work if input has many same element. For instance,

      2 2 2 2            2   2 2 2
1 1 1             -> 1 1   1 

One solution to this problem is: notice that all the odd indeices will contain larger elements and even indices will contain smaller elements (or otherwise)

I tried to solve this without extra space, but I found it tooooooooooo tough through it seems not. This is what I tried:

I sorted the array. Then find out where the larger number will begin. Now, all I need to do is fill up the odd indices with the larger numbers. But, this is easier said than done.

For instance, I iterate odd indices from left and iterate larger numbers from right and swap in every iteration. But, this does not work because a large element will be swapped out.

So, I iterate odd indices from the left and large elements from left. It works for some cases, but still results in same element being placed adjacently. To solve the problem, I tried to reverse the larger numbers. That solves the problem for some cases, but problem still exists. Then tried to reverse smaller problems. It solves the problem, but still problem exists.

So, I give up in place wiggle sort!!!!! Need to try using extra space.

Now, wiggle sort can be thought as we have two sorted array A and B (A contains smaller elements and B contains larger element). We need to merge this two arrays by taking one element from each array at a time and placing them adjacently. There are 4 differert ways we can do that:

A           B
---------------
L-R        L-R  (should work, but doesn't in leetcode)
L-R        R-L  (Not good)
R-L        L-R  (Not good)
R-L        R-L  (good)    

Note that, largest element of A can be same as smallest element of B. 

If we do R-L for B and L-R for A, then there is a good chance that same element will be placed adjacently. So, if we do R-L for B, we should do R-L for A.

Again, if we do L-R for B and R-L for A, then there is a good chance that same element will be placed adjacently. But, L-R for A and B should work, but not for small array. And I found it does not work in leetcode test code.

136. In post order, root is visited at the last. But, it sounds linke something else.

137. In-order, pre-order, etc can be same for differenet trees. But, in-order and post-order would be unique for a tree. So, you may be asked to construct a tree from inorder and postorder travarsal.

Try to think first before looking at the solution.

If look carefully for a while, you will find that root of a tree will always come at last in post order travarsal. We can use this property to split the tree into two subtrees. This is how we can construct the tree recursively by splitting...here post order travarsal will give us the root.

Also note that inorder and post order travarsals are also aligned. In inorder, the whole left subtree is travarsed, then root is travarsed and the whole right subtree is travarsed. On the otherhad, in postorder, the whole left subtree is travarsed, then whole right subtree is travarsed and then the root is travarsed. So, both travarsal are kinda alighned. So, you can split those arrays at the same time to produce subtrees.

I shoud note that problem can be asked to generate a tree from preorder and inorder travarsal. The solution is alsomost the same except in preorder, we will find the root at the beginning (instead at the end in case of postorder).

Another very important point!!!!: note that inorder and postorder array are not properly aligned. So, using index of one to caluclate index of the other will result wrong result. But, this problem can be solved using a simple technique. From the previous discussion, it is clear that the size of inorder and postorder array would be same as they corresponds to a subtree. Thus we can calculate how many elements are there in the left subtree. We can use that to calculate the index of the inorder and postorder arrays.

138. For instance, I have a n X k 2D array. I'm iterating them as:

for (i = 0; i < n; i++) {
  for (j = 0; j < k; j++) {

  }
}

Here, i corresponds n and j corresponds k. It may sound trivial, but it may seem confusing sometime. Inside the loops, we need to use i and j instead of n and k.. Also, you may use 'row' and 'col' instead of i and j.

139. Sometimes, in 2D array, you may create (n + 1) X (k + 1) array instead of n X k array. Instead of mapping an element to appropiate index by subtracting 1, we can use the element to map directly to the array element.

140. If needed, sometime, you can create min()/max() macro yourself, like #define max(a,b) (a < b ? b : a)

141. In egg-drop problem, we need to count what would the minimum number to steps needed for a given number of floors (n) and eggs (k). Note that, we don't need to find out the floor. If you needed to find the floor, we could do binary search like approach. But, here, the problem is different. We need to count the minimum number of steps, and counting minimum number of step through binary search like approach (checking the mid element first) may not need least amount of steps. In some cases, I found checking one-third-th element first will require fewer number of steps. So, here the equation is more complicated that binary search. We need to check for each floor to find the minimum # of steps.

Now, we need to write down the function that checks all the floor to find the minimum like:

https://www.geeksforgeeks.org/egg-dropping-puzzle-dp-11/

Then peform DP instead of recursion.

Now, note that, do you really need to check for all the floors? 

https://leetcode.com/problems/super-egg-drop/solution/ 

The link shows you don't...

If you have two functions f1 and f2. f1 is always increasing and f2 is always decresing and you are taking the min of max of them (like the link), you can apply binary search like approach!!!! So, I guess, we are eventually using binary search, but not in the way I thought I would be....

\   /
 \ /
  /\
 /  \
/    \
f1   f2

142. Common variable names: i, j, k, m, n, row, col, res, tmp, ret, mid, hi, lo, start, end, count, cnt, res_cnt, num_col, num_row, mat, arr, s, ch, str, dp, stack, queue, s_idx, q_start, q_end, runner1, runner2, r1, r2, r1_nxt, r2_nxt, elem, left_idx, right_idx, parent_idx, list_head, num_bucket, backet, to_find, to_insert, adj_row, adj_col, ...... struct elem, struct node, struct cell, truct tuple, key, value, new_node, node, bucket, bucket_no, node_queue, len_queue, cur_node, cur_len, val, tweetId, userId, heap_len, cur_idx, max_idx, struct ListNode *slow, *fast; struct ListNode *slow_runner, *fast_runner, prefix_sum, suffix_sum, num_bits, L (for lengths), numerator (up), denominator (down), hi, lo,  

struct followee* f;
struct tweet *t;

143.   char *str = "aabbcaad"; ..is fine..no need to do char str[] = {...};

144. Sometimes, you will need a data structure where we store count of each element. We extract an element with largest/smallest count from the data structure and decrement the count...Heap is a perfect data structure for this kinds of problems. For instance: reorganize-string problem.

145. Be careful, when you have '-' in a expression. For instance, in heap push_up(), we need the following expression:

  int parent_idx = (idx - 1) >> 1;

Now, we use this expression to calculate the parent index of a tree. Now, if idx == 0, then this logic is screwed. Even following logic is screwed too!

int parent_idx = (idx - 1) / 2;

We need to add an extra check before the expression. If idx == 0, then there is no parent... 

Note that, this creates a VERY hard to find bug..

146. May be I am reapeating, but don't try to create a 1D array to represent a 2D array. 2D array produces much cleaner code.

147. When checking if we can place a queen in two positions, I write the logic like:

return !(x1 == x2 || y1 == y2 || (x2 - x1) == (y2 - y1));  

But, it should be:

return !(x1 == x2 || y1 == y2 || abs (x2 - x1) == abs (y2 - y1));

Because, diagonal can be right-down and right-up.

148. If you need to check eqaulity of float or double, note that it would not work. For instance, in max-points-on-a-line, we need to create a map where key is the tangent of two points (y2-y1/x2-x1). To solve this precision problem, I should store y2-y1 and x2-x1 separately as int and use them as key.

Now, problem is how can I tell (3,4) and (6,8) are the same key? One apparent solution is to check if 6/3 == 8/4...But, note that this would not work for all the inputs. For instance, 6/3 == 9/4..

To solve the problem, we need to calculate GCD of 6 and 8 and divide the numbers by the GCD. That is, we will always store key as the reduced value like (2, 3) or (3,4) and so on.

149. Note that, you often need to create a list of something and check if an element already exists in the list. For instance, max-points-on-a-line problem. You can use map (balananced binary tree or binary tree) or hash to implement that. If there is an order between key, you can create a binary tree, I think.

Note that, to begin with, we can simply create a list.. and later change it to hash or map which is appropiate.

Note that, you will find much better performance with hash than binary tree. So, if you have an option to use hash or binary tree, go for hash (even though there are order among the numbers)!!!!!


150. Note that, list_insert should look like following:

void list_insert (struct value **head, int val)

Inside the function, you should use *head to use the head.

Orrrrr, you can do this:

struct value* list_insert (struct value *head, int val);

It will return new head!! I that case, you can use head directly and not use *head.

151. Suppose, you want to compare two numbers: x/y > a/b. Here all of them are int. This will not work. You should cast lhs and rhs to double.

152. In max-points-on-a-line problem, I may store tangent (y2-y1/x2-x1) as key as suggested in geeksforgeeks. But, note that tangent is not enough to check if some points are one a line. Specially tangent of two point pairs can be 0 or INFINITE and they may not be on the same line. Right question to ask here is how to check if three points are on the same line? In that case, we need to store 2 points. If we store (x1, y1) and (x2, y2), we can tell if another point is on the line. 

We do that by checking if x1 == x2, in that case we check if new point x == x1..Same for y axis. We also check following if x1 != x2 and y1 != y2:

(x - x1)/(x1 - x2) = (y - y1)/(y1 - y2).

153. Hot brownie helps to keep brain cool.

154. Sometimes, towards the end of the day, I look at a problem. It may seem quite tough. I try to come up with some solution on paper. The solution does not work. In the next moring, I start fresh. Look at the solution little differently. Now, the solution look easy. 

Moral: Sometimes it takes a fresh rethinking to solve a problem.

155. Sometimes, you may come across a problem where you need to check if you came through this path. This problem particularly arise in sequence building. In that, check if you can solve this using DFS/BFS. Usually you can. An example of such problem is longest-consecutive-sequence.

But, note that, when you really want to create a sequence, do you really need to start from the any node. For instance, in longest-consecutive-sequence problem, you are given an array. The first element of the array may not be the first element of the sequence. This is why, you may need to look both ways to create sequence. Solving this problem with DFS and BFS also involve havinhg visit array so that we don't visit an element if we visited before. But, all this problem can be simplified if we only start with elements that's the start of a sequence. In that case, we don't need to look bi-directionally. We only look unidirectionally. For instance, Approach #3

https://leetcode.com/problems/longest-consecutive-sequence/solution/  

156. struct node *hash[1000] = {NULL};

This is how you can initialize a hash or pointer array.

157. Note that, implementing hash should be pretty easy. And you have access to your hash function, so it's better than using C++ built-in hash!! :-)

158. When accessing hash, check if you element can be negative or not. If they can be negative, you need to make them positive.

159. When iterating a matrix, we can follow this paradigm:

  for (row = 0; row < num_row; row++) {
    for (col = 0; col < num_col; col++) {
      
    }
  }

Instead of

  for (i = 0; i < num_row; i++) {
    for (j = 0; j < num_col; j++) {
      
    }
  }

160. Sometimes, it's critical to choose where do we start DFS from. For instance, in pacific-atlantic-water-flow problem, it is natual to start doing DFS from nodes one by one if they are unvisited. But, this lead to visiting same node many times. But, if you think carefully, all the water goes to ocean. So, we can simply start DFS from ocean (nodes adjacent to ocean)

Note, that kind of problem (e.g. pacific-atlantic-water-flow) may appear to be solved  by a simple DP. But, if you look carefully, if you are using DP, you are not considering all the adjacent nodes (in all 4 directions). You are only considering 2 (left and up). So, it will not work.

161. Sometimes, in stack, you may not need to pop from the stack. You rather insert and modify the stack. For instance, longest-valid-parentheses problem.

162. "Window of substring of a string" == "substring of a string" == "window of a string". The wording can be confusing.

163. To check if a character is lower or upper case, there is a function: int islower(int c);

It returns non-zero if c is a lower case, it returns 0 if c is an uppercase.

164. There is no function to create a subtring from a string (index i to j). You can create your own:

  int res_len = min_end - min_start + 1;
  char *res = (char *) malloc ((res_len + 1) * sizeof (char));
  res[res_len] = '\0';
  memcpy (res, s + min_start, res_len * sizeof (char));
  return res;

Also note that, we don't need to use calloc to initialize all elements to 0.

165. Just for quickness sake, rememember that, to iterate all the elements of a string based on string length, you need to do this:

int len = strlen (s);
for (i = 0; i < len; i++) {

}

166. Sometimes, you may want to skip the beginning of an array. You may do that as:

  left = 0;
  while (!exist (hash, s[left])) {
    left++;
  }

Problem with this is you skip all the characters, so you will get segfault. So, it should be:

  left = 0;
  while (left < s_len && !exist (hash, s[left])) {
    left++;
  }

Anytime, you increase an index in a while loop or for loop (mostly happen in while loop in my case), be sure to check if the index is a valid index or not.

Note that, you also need to add following:

  if (left >= s_len)
    return "";

So, if left really exceeds array length, you want to write what you want to do.

167. We you have substring matching type problem (e.g. minimum-window-substring), you we perform sliding window type algorithm. There, we maintain two variables: left and right. Note that, sliding window algorithm is similar to KMP string matching algorithm (not 100% sure). 

The details of slinding window algorithm would be found at:

https://leetcode.com/problems/minimum-window-substring/solution/

Note that, in this algorithm, the left pointer should not reach to the end. If lengths of string s and t are s_len and t_len respectively, left pointer should go up to (s_len - t_len). If s_len goes till end, it will still work, but it will be highly inefficient specially if t_len is pretty high. 

Note that, implementation of slinding window can be treaky. You can implement it like:

  while (1) {
    //need to expand the right
    while (1) {
      if (right >= s_len)
        goto done;
      if (exist (hash, s[right])) {
        match_cnt++;
        if (match_cnt == t_len)
          break;
      }
      delete (hash, s[right]);
      right++;
    };
    //need to expand the left
    if (right - left + 1 < min_window_len) {
      min_window_len = right - left + 1;
      min_start = left;
      min_end = right;
    }
    insert (hash, s[left]);
    left++;
    match_cnt--;
    while (left <= s_len - t_len && get_value (hash, s[left]) < 0)
      left++;
    if (left > s_len - t_len)
      goto done;
    if (left > right) {
      right = left;
      break;
    }
  }  
done:
  if (min_start == -1) {
    return "";
  }

But, it becomes very messy. But, you can still think of it as substring matchig. So, your left visit from 0 to s_len - t_len. And then expand right internally. The above code can be implemented as:

  while (left <= s_len - t_len) {
    while (right < s_len && match_cnt < t_len) {
      if (get_value (hash, s[right]) > 0)
        match_cnt++;
      delete (hash, s[right]);
      right++;
    }
    if (match_cnt < t_len)
      break;
    while (get_value (hash, s[left]) < 0) {
      insert (hash, s[left]);
      left++;      
    }
    if (right - left < min_window_len) {
      min_window_len = right - left;
      min_start = left;
      min_end = right - 1;
    }
    insert (hash, s[left]);
    left++;
    match_cnt--;
  }

Note that, unconditional while can be simplified by moving internal breaking condition to condition.


168. Note, that we may need to keep track of minimmum window len, window start and window end (e.g. minimum-window-substring problem). We don't need to three variables to do that. But, I often use three variables. Instead, you can use start and min_window_len to do that.

169. Sometimes, it may seem that you need a copy of your hash function and modify that.. and in some point you need to create a fresh copy of the hash. For instance, minimum-window-substring problem. 

Now, think carefully, sometimes, it is possioble to use the hash so intellegently that you don't need a separate copy of the hash. You can modify the hash as you go..For instance, this is a solution to minimum-window-substring problem:

https://leetcode.com/problems/minimum-window-substring/discuss/1360317/Simple-c%2B%2B-solution-or-Sliding-Window-or-Hashmap-or-Explained-clearly-with-comments

 string minWindow(string s, string t) {
        // Initialize minl as INT_MAX
        int minl = INT_MAX;
        
        // Map to keep count of all characters of t 
        unordered_map <int, int> mp;
        for(auto ch: t) mp[ch]++;
        
        // Sliding Window Approach
        // Let c be the count of chars of t in a particular window. Initialize as 0
        // start be the start of the current window
        // end be the end of current window
        // minstart be the start for the minimum window found yet.
        
        int c = 0;
        
        int start = 0;
        int minstart = 0;
        
        for(int end = 0; end<s.length(); end++)
        {
            if(mp[s[end]]>0) c++;
            mp[s[end]]--; 
            
            // continue untill c equals length of t or when current window has all characters of t in it
            if(c==t.length())
            {
                // Note that negative values in map indicate the key char is not present in t, but present in s. And hence leading chars in s with negative values are insignificant.
                
                while(start<end && mp[s[start]]<0){
                    mp[s[start]]++;
                    start++;
                }
                
                if(end-start+1<minl)
                {
                    minl = end-start+1;
                    minstart = start;
                }
                
                // reduce the window size by incrementing start, reducing mp[s[start]] value, and reducing c
    
                mp[s[start]]++;
                start++;
                c--;
            }
        }
        
        if(minl==INT_MAX) return "";
        return s.substr(minstart, minl);


very important point!!!!!!
------------------------------
Note that, hash can keep track of what charater we need to look for in the sliding window. The hash also can keep track of what character we need to skip.

170. A very common mistake and hard to find bug!!!!

If you need to set array of characters where the array elemements are number (e.g. sudoku-solver). I often do:

board[i][j] = k;

But, I should have done:

board[i][j] = '0' + k;

171. Sometimes, in backtracking, there can more different types of return condition. For instance, in sudoku-solver, there are two return statements:

void solveSudoku_inner(char** board, int num_row, int num_col, int row, int col, bool *done)
{
  int i, j, k;
  
  for (i = 0; i < num_row; i++) {
    for (j = 0; j < num_col; j++) {
      if (board[i][j] != '.')
        continue;
      int hash[10] = {0};
      get_valid_values (board, num_row, num_col, i, j, hash);

      for (k = 1; k <= 9; k++) {
        if (!hash[k]) {
          board[i][j] = '0' + k;
          solveSudoku_inner (board, num_row, num_col, i, j, done);
          if (*done)
            return;
          board[i][j] = '.';
        }
      }
      ///Needed!!!! Coming here means we couldn't find appropiate value, so backtrack.
      return;
    }
  }
  //This return found a solution
  *done = true;
}

172. In heapify () or min_heap, name like parent_idx, left_idx, right_idx:

void push_down (int *arr, int len, int parent_idx)
{
  int left_idx = (parent_idx << 1) + 1, right_idx = (parent_idx << 1) + 2;
  ...
}

Also you need to keep track of min child. Check the left child first, then check the right right. Checking right child first makes things complicated, because right child may not exist...you know what, checking anyone at first is fine... but, checking left first ofcourse makes it easier!

Also, I forget to check "max_child_idx >=0" in following. This causes segfault!!!: 

  if (max_child_idx >=0 && arr[max_child_idx] > arr[parent_idx]) {
    tmp = arr[parent_idx];
    arr[parent_idx] = arr[max_child_idx];
    arr[max_child_idx] = tmp;
    push_down (arr, len, max_child_idx);
  }

173. How would you update an elemnement of a heap? One thing you can do (from my common sense, not sure if it's correct) is perform push_down() at that index assumeing that index is a parent. If the new number is larger than previous number, also perform push_down() for all the prior indices of the index. It's like we are creating the heap again. But, instead of starting from the very last parent, we start at the index where the value is updated.

This however would be very inefficient!!!!!

What you should do is:

If the new number is larger than before, perform push_down(). If the new number is smaller than before, perform push_up (). This is in min-heap.

Now, this is inefficient either!!!!!!!!!!

Note that, you update an heap at each iteration, you are using O(log n) everytime. Heap is more efficinet if you don't update heap in every iteration. For instance, take sliding-window-maximum problem as an example. It may seem that you should have a fixed size heap of size k. In every iteration, you should remove one element and add another element. Or you simply can update the ulemment. If you do that, you will get TLE because it's not so efficienet. 

What you should do instead is you should have a large heap and update size of the heap at runtime. In each iteration, you shoud add a new element. Then you should check if top of the heap is out of the window; if yes, remove it. In this approach, we also need to store index along with value. In this approach, we don't need to remove element at each iteration. 

Thus, if you need heap_update() , you should think if you really should do that. You should think if you can solve the problem such that you just need heap_add() and heap_delete()

174. Sometimes, you may need to create an struct object. The simplest syntax for that is:

  struct node n1, n2, n3, n4, n5, n6, n7, n8, n9, n10;
  n1 = (struct node) {1, &n2, &n3};

Note that, it is NOT (I often think so):

  struct node *n1, *n2, *n3;

Note that, it is also NOT (I often think so):

  n1 = (struct node) {.id = 1, .left = &n2, .right = &n3};

175. "stack buffer underflow" happens when you try to read to the left of an array. 

176. Sometimes, a data structure is needed for each iteration rather than all iteration. For instance, max-points-on-a-line problem require maintaining a hash where keys are tangent. But, note we can use tangent to tell if a point is one a line if one of the point is fixed. So, we will need a hash for each iteration. In other words, we need a hash for each point. Each hash will contain tangets of other points with respect to that point.

https://leetcode.com/problems/max-points-on-a-line/solution/

Sometimes, it does not seem clear with which respect we do something. In those situations, we can consider similar solution.

Also, note that, you may need to store counter per hash entry or a global counter. For instance, in max-points-on-a-line problem, you are considering one point at a time. Now the points can be as following:



          e
     d

a        b          c

Here, there are three points on the same line when considering point a. Note that, here, we need to store count per slope. If we use global cointer, the counter will wrongly return 5 instead of 3.

177. Sometimes, I use flag to store state. For instance, in find-median-from-data-stream problem, I tend to use a flag (enum) to store which heap the data was inserted last. But, if you think carefully, it's not needed. You can use heap's size to infer which heap was inserted last. I guess, similar approach can be used elsewhere. Any time you use a flag (enum) to store state, think again if you really need that.

Again, check if you really need a varuable? For instance, find-median-from-data-stream problem, you can have count, min_heap_cnt, and max_heap_cnt variable. But, if you think carefully, count = min_heap_cnt + max_heap_cnt.

Also, having a separete counter may save some operation during computation, it also means, you are maintaining an extra new state. Getting rif of that will certainly simplify the code.

178. In find-median-from-data-stream, you can define the data structure as following:

typedef struct {
  int *max_heap;
  int *min_heap;
  int max_heap_cnt;
  int min_heap_cnt;
} MedianFinder;

You can also declare it as following:

struct heap {
  int *arr;
  int count;
};

typedef struct {
  struct heap *max_heap;
  struct heap *min_heap;
} MedianFinder;


What are the pros and cons abount the above approaches?

Second approach is better for implementing generic heap functions. In first approach, client code has to keep track of the heap length. 

Buuuuuut, in first approach, we need fewer indirections. For instance, in second approach, we need to write code like "obj->min_heap.arr", ""obj->min_heap.count"" which seems ugly. So, writing code with fewer indirection definately produces cleaner code!!! Favor that!!!

In large projects, this problem can be fixed by writting simple macros to access the inner elements...

Now, we should use first approach which uses fewer indirection. But, with nice API, we can avoid clinent code having to do with increamenting max_heap_cnt, min_heap_cnt count..

For instance, 

void heap_add (struct elem *arr, int *len, int to_add)

Here, max_heap_cnt, min_heap_cnt would be passed as a reference and incremented internally.

179. In find-median-from-data-stream problem, we need to maintain two heaps. To decide, to which heap we add a new data, we check the size of both heaps. If the size of both heaps are the same, it's easy to decide where to add the new number. If the size of the two heaps are not the same, one heap has one more item than the other. In that case, it is not hard to decide to which heap the new data should be added. But, think about it. If one heap has 1 element and the other heap has 0 element, the heap with 0 element has random value at 0-th element. So, we should not compare that with the number to be added., We should compare the number_to_be_added with the first element of the heap with 1 element. Otherwise, it causes a bug.

180. Never under estimate the value of a long walk, clearing the head,... suddenly nice and clear solution comes to your mind!!!!!!

181. Writting code often takes around 30-45 minues (including bug fixes..). Clearing the head and coming up with a nearly good solution takes 1.5 hours...

182. To calculate sub-array sum (i.e. subarray-sum-equals-k problem), we cab do:

  for (i = 0; i < numsSize; i++) {
    sum = 0;
    for (j = i; j < numsSize; j++) {
      sum += nums[j];
      if (sum == k)
        count++;
    }
  }

We can also solve this issue with prefix sum as:

  for (i = 0; i < numsSize; i++) {
    if (prefix_sum[i] == k)
      count++;
    for (j = 0; j < i; j++) {
      if (prefix_sum[i] - prefix_sum[j] == k)
        count++;
    }
  }

Note that, they are not better than each other. Both are O (n^2)

Now, the prefix sum approach can be improved by using hashmap. We should store the prefix sum in hash map. Every time we insert a prefxi sum, we also should check if target - prefix_sum exists in the hashmap. Using that approach, we can solve the problem in O (n). For details, take a look at approach #4 at:

https://leetcode.com/problems/subarray-sum-equals-k/solution/ 

In other words, we need to find touples for which A_i - A_j == Target.

If store all As in a hash map, given a Target, We can find all the touples in O (n). (Very intersting!!!!!!!!)

Note that, here we need to store number of occurance of a prefix sum, otherwise it will not work. I tend to only store the prefix sum. But, without the number of occurance, we will get wrong result.

183. If you need to do topological sorting, try to use DFS to implement that. It is much to remember the actaul toplogical sorting algorithm. 

In the same way, if you need to use KMP string matching algorithm, use Sliding Window algorithm instead. It's easier that way.

184. When using DFS, think if the graph is connected. Connected graph means this a path among every nodes in the graph. If the graph is not connected, you can simply do that as following:

  for (j = 0; j < numCourses; j++) {
    if (visit[j])
      continue;
    //actual DFS
    start = j;
    s_idx = 0;
    stack[s_idx++] = start;
    while (s_idx) {
      cur = stack[s_idx - 1];
      if (visit[cur] == 2) {
        s_idx--;
        continue;
      }
  }

Note that, I tend to add another condition as folowing in the above code:

    if (visit[j] || indegree[j])
      continue;

But, this is not needed!!!!!!! We can start DFS at any node, it does not have to have an indegree of 0. Moreover, adding indegree to the logic will cause bug. The reason is, there may be a graph or connected subgraph which does not have a node with in-degree 0. We may want to start with any node in that case...... THis is a very important issue!!!!!!!!!!!

185. If you are asked separate stack/queue code from client code, you can create your own stack/queue struct and associated function. Like:

struct Queue {
  struct TreeNode* nodes[CAPACITY];
  int len[CAPACITY];
  int start;
  int end;
};

void queue_init (struct Queue *q)
{
  q->start = 0;
  q->end = 0;
}

void enqueue (struct Queue *q, struct TreeNode* n, int len)
{
  q->nodes[q->end] = n;
  q->len[q->end] = len;
  q->end++;
}

void dequeue (struct Queue *q, struct TreeNode** n, int *len)
{
  *n = q->nodes[q->start];
  *len = q->len[q->start];
  q->start++;
}

bool queue_empty (struct Queue *q)
{
  return q->end == q->start;
}

186. For hash, using #define CAPACITY 1000 is fine.

187. Define hash elements as following:

struct elem {
  int key; //use key ...
  int val;
  struct elem *next;
};

188. In hash, you can implemet:

bool exist (struct elem **hash, int key)

or 

struct elem* find (struct elem **hash, int key)

Think which one you need. I often found exist() is not enough and I need find().

189. You can also name the functions like:

hash_insert(), hash_find()...etc

190. If you need top k elements of n, it's more efficient to use heap instead of sorting because it would be klogn. If k is much smaller than n, it will be good!


191. You can implement heap interface as:


void construct_heap (struct elem **heap, int len);

struct elem* heap_pop_root (struct elem **heap, int *len)

Note that, in second function, you are passing the len as pointer. So, client code don't need to worry about maintaining the length.

192. When implementing hash, do:

 int bucket = abs (key) % CAPACITY;

I often forget abs() which cause problem if key is negative.

193. Suppose, you are supposed to design a twitter class (e.g. design-twitter problem). Your twitter class should have:

postTweet(int userId, int tweetId);

This means that, you are not designing TwitterUser class (I mistakenly thought I was). Both Tweet and TwitterUser classes are external. Here, we are going use those classes' ID to implement basic functionality. 

Note that, here we need to store mapping between user ID and followers/followees. We also need to store mapping between user ID and tweet IDs. We generally store these mapping in Database. But, here we are storing them in application.

194. If you are asked a design question, https://leetcode.com/problems/design-twitter/ is a good example..

195. Note that, we often use heap as a temporary data structure. So, we preallocate heap as an array. But, we also maintain a heap_len

196. You can implement heaps in two ways:

1. heap_delete and heap_construct(). Both of them will need push_down()
2. heap_delete() and heap_add(). heap_delete() will need push_down() whereas heap_add() will need push_up().

Choose one of the two ways depending on your need. Sometimes, you will construct the heap only once. And then only do heap_delete(). In that case, you can use process 1. But, if you need to perform head_add() run time (e.g. design-twitter problem), you can use process 2.

197. I often go ahead and use hash map where keys are elglish letter. You can simply use an array here!!

198. One common problem is: I often need to sort an array where array index means someething like key of a hash. But, when I sort the array, the index is messed up. How can I solve this problem?

One trivial way to solve this problem is to create a new array of type struct elem where elem is:

struct elem {
  int val;
  int index;
};

After sorting the array, we will still have our index. But, problem is it is very expensive. A better solution is described here:

https://stackoverflow.com/questions/4859261/get-the-indices-of-an-array-after-sorting

So, don't sort the original array at all. Create a new index array. Sort the index array. When sorting the index array, sort it based on the value of the original array. Like:

//global varuable so that it's accessible inside cmp
int hash[26] = {0};//int *hash; is fine as well

int cmp (const void *a, const void *b)
{
  return hash[*((int *)b)] - hash[*((int *)a)];
}


int func () 
{
  int indices[26];

  for (i = 0; i < 26; i++) {
    indices[i] = i;
  }
  
  qsort (indices, 26, sizeof (int), cmp);

  for (i = 0; i < 26; i++) {
    //now access this way.....
    if (!hash[indices[i]])

  }
}
  

199. If you use global variable, you must initialize it inside function. Otherwise, it will give you wrong value from the function. For instance, in the above code, you should do following in the func():

memset (hash, 0, 26 * sizeof (int));


200. In heap_delete(), we do:

heap[0] = heap[*heap_len - 1];

Note that, if *heap_len == 0, it will crash. So, anytime, you do 'minus' in array index, think if it will ever be negative. If yes, handle the situation separately. Like:

  if (!(*heap_len))
    return;

201. Sometimes, you may need to sort an input array. But, sometimes, you may need to keep your input array in sorted manner and update it (for inatance, task-scheduler). Sorting the array will not cut it. For instance, you max need to extract the largest number, update it's frequency and insert it back in every iteration. We can use heap to solve this problem...

In this, I may wonder when should I delete and insert to heap. For instance, in task-scheduler problem, we can delete and insert it back in every iteration. But, if we get same character in two consecutive iteration, we cannot place them side by side. Intelligent thing is to delete it in every iteration, but after passing n iteration, insert it back. That way we don't need to worry about getting same characters in the consecutive iteration. 

202. Sometimes, you input a 2D array (e.g. minesweeper problem). You are asked to return a 2D array. This does not mean you need to create a new array (although you could). You can simply update the input array and return it. 

It's like in list_insert(), when we input a list_head and return a list head. We don't want to update the input. Rather we want to return the head. This creates cleaner API. In order to update input, we need to pass pointer to the head instead of head and then use "*head" everytime you want to use head. This is not very clean.

203. I may be tempting to write all the logic in a function. But, don't do it. Write a separate function. This is more professional, produces clean code, 

204. When doing DFS recursively or visiting all the adjacent cells recersively, I forget that I will need visit array to keep tracking of wheather I visited a cell or not.

205. If you are asked to sort a linked list, first thing to ask is to what is the desired runtime? If O(n^2) is acceptable, bubble sort can be implemented pretty easily. Here, we don't need to manipulate pointers (I suppose) and just swap the value. If we use insertion sort, note that we can't do random access in linked list, so we will few pointer manipulation in insertion sort.

Now, if O(nlogn) is expected, we can do quick sort and merge sort. The worst case time of quick sort is O(n^2), but average case runtime is O(nlogn). On the otherhand, merge sort is really O(nlogn). Implementing quick sort on linked list can be pretty tricky, but merge sort is easier... Take a look at both top-down and bottom-up approaches. I like bottom up approach because it does not need recursion (extra space), and more logical. I remember, I often use to wonder why do we implement merge sort the way we do. It's more natural to implement it in bottom-up fashion. 

https://leetcode.com/problems/sort-list/solution/


Now, if you look carefully, bottom-up implementation is much harder than top-down because you need to group every 1, 2, 4, 8,...elements. In top-down approach, we don't need to worry about that. We can simply write generic logic to split and merge.... So, this is why top-down is preferable.. 

Now, how would you implement top-down merge sort? One solution is to send head and tail of a linked list. Then find the middle. The perfor merge sort as:

struct ListNode* merge_sort(struct ListNode *head, struct ListNode *tail)
{
  struct ListNode *mid;
  
  if (head == tail)
    return head;
  
  mid = get_mid (head, tail);
  merge_sort (head, mid);
  merge_sort (mid->next, tail);

  //merge based on the heads and tails returned from the above function 
}

Note that this is just a psudocode. We need to return both head and tail from merge_sort function so that we can merge them appropiately. Implementing this is obviaously a night-mare!!! Can we simplify this? Can we implement it such that we don't need to maintain tail? 

One way we can do is, when get mid, we really set mid->next = NULL. That is, we literally split the linked list into two two linked lists. THis simplifies the logic enoumously!!!!!!!!!!!!!!!!!!!!!

Now, we don't need to keep track of end!!!!


Keep in mind that, merging is the most critical code of merge sort, rest of the code is easy..so don't over think it :)


205. Sometimes, a problem look simple. For instance, kth-smallest-element-in-a-sorted-matrix problem, it may appears that we use simple division and modulous to find the appropiate index. It will indeed work if all the numbers are distinct.

But, there are many same numbers, the simple approach will not work. But, in that case, the problem can be solved by keeping track of the visited list, candidate list, and unvisited list (we can have a separate state matrix and store 0, 1, 2 to do that). In every iteration we extract the minimum. And then we add few more elemenent which are candidates.

Note that, this approach will be very expensive as we will need O(n^2) to find the minimum at every step.

We can improve the solution by using a heap. 

The problem can also be viewed as finding k-th element in n sorted list as suggested in:

https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/solution/

Thus, the problem become very similar to merging n sorted list.

Don't forget that if you need to find min/max among a dynamic list, you should use heap!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

206. For instance, you are asked to delete all the consecutive elements of a list where their sum equl to 0. We can maintain prefix sum and store it in a hash. If a prefix sum is previously seen, then we know that elements since then to now equal 0....

Now, there is a catch. If prefix sum is 0, then all the elements from the beginning till now equal 0 (I often forget this). Note that, with this algorithm, you don't even need to worry about treating elements with 0.

This is a very important observation!!!!

207. Sometimes, you need to do sequential search to find maximum of something (e.g. maximum-xor-of-two-numbers-in-an-array or lingest prefix match). Here, sequential search will be very expensive because it may contain millions of entries. To increase the search speed, we often use binary tree (map) or hash. Note that, we really can not use binary tree or hash, becuase here we are not really searching anyting. We are rather testing elery element. We need to test elements in a way that we don't need to test all the elelements. And that's how we increase the efficiency!!!!!! So, how can we reperent the input that we don't need to test all inputs. Ratther we can can consider some and skip the rest...?

Two ways to achieve those is Trie !!!!!!! (very important!!)

https://leetcode.com/problems/maximum-xor-of-two-numbers-in-an-array/solution/

Take a look at bitwise tree approach here!!!!

208. What is the number of digits needed for an integer? I often think of this problem as two groups: 1. numbers that are multiples of 10 and numbers that are not multiples of 10s.

So, I tend to write the logic as:

n % 10 == 0 ? log10(n) + 1 : cell (log10(n)). 

But, it is overly complicated!!! Think carefully...you can write the logic as:

num_digits = log10(n) + 1.

This will work for all the cases!!!! Note that, the logic is same for 10-99..


In the same way, what is the number of bits needed for a number?

num_bits = log2(n) + 1;


209. For instance, you have many numbers. What is the minimum number of bits needed to represent all the numbers? 

It is the number of bits needed for the maximum number of the input numbers....This is very obvious. But, it does not come to mind natuarally when come across in a problem like maximum-xor-of-two-numbers-in-an-array problem.

210. What is the runtime of Trie lookup? It's the height of the trie. For instance, in maximum-xor-of-two-numbers-in-an-array problem, the height of the trie is L where L is the number of bits. In this case, runtime will be O(L). Note that, you may visit more than one branch of a trie (for instance, maximum-xor-of-two-numbers-in-an-array problem). In this case, the runtime is O(n) because we may end up visiting all the nodes. But, not more than n..


Added later
----------------
Actually previous discussion was wrong!!!! Lookup in Trie is O(L) in other words O(1). Now, note that you cannot find the maximum-xor-of-two-numbers-in-an-array in one Trie iteration. I often try to do that mistakenly. I use two pointers. But, I notice that in 3rd level, I will need 4 pointers, in 4th level, I will need 8 pointers, and so on....so, clearly it's not the right way.

What we need to do is, we need to perform search for each number at a time. For each number, we need to find the number that results maximum XOR. That is, we need to perform trie lookup n time. That's why, lookup time is O(n).

211. if (ret ^ nums[i] > max) will return wrong result!!!! It should be:


if ((ret ^ nums[i]) > max)

212. For instance, you are asked to return a string from a function (e.g. fraction-to-recurring-decimal). I mistakenly allocate the string statically, fill it up with sprintf() and return it. It will not work because the string will be disallocated!!! It is very trivial, but I make the mkistake.

213. sprintf (ret, "%s(%s)", res, fraction); is fine. We don't need \( \)... but, I remain confused if I need it or not

214. For instance, in fraction-to-recurring-decimal problem, I can input:

2       4
-- ,   -----
5       333

In each step, if nominator is smaller than denominator, I add 0 till it's smaller than denominator, then I do the actual division. Problem with this approach is I am trying to do two things at the same time. What I can do is, in each step, if nominator is smaller than denominator, then add 0; otherwise calculate the division. This simplifies the logic enourmously!!!! So, in a step, if you need to do some preprocessing before performing the actual task, think if you can simplify this. If you can generalize the preprocessing with actaul task, you write generic logic. 

215. I got following error with int a = abs (b);

"negation of -2147483648 cannot be represented in type 'int'; cast to an unsigned type to negate this value to itself"

To fix the problem, do this:

long a = labs (b); prototype of labs is : long int labs(long int x)

This is very important!!!

216. In maximum-product-subarray, we you can simply use bruteforce solution which would be O(n^2). Note that, if you use DP where you calculate product of subarray of length 1, 2, 3,...it will also be O(n^2). However, aparently there is a better DP solution that can achive O(n) which is very similar to "Largest Sum Contiguous Subarray". So, it's worth taking note!!

This problem can be solved in O(n). First take a look at maximum-subarray problem. Think if you can solve maximum-subarray or maximum-product-subarray in O(n). If not, double check the solutions...

Note that they are not DP.

217. It's worth reiterating that min() and max () are not built-in function in C. If needed make your own function or macro.

218. 

