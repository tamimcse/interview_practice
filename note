1. To include "match.h", need to use -lm to compile

2. In backtracking algorithms, the inner algorithm should not return anything. The inner algorithm should return the outout as input.

3. cmp in qsort():

int cmp (const void *a, const void *b)
{
  return *((int *)a) - *((int *)b);
}

3. qsort prototype: qsort(arr, len, sizeof(arr[0]), cmp);

I often forget which one come first, lenght or size of the element. Remember, length comes first.

4. When returning char *, note that char * should also include '\0'. So, when allocating it, allocate one character extra.

5. when assigning NULL to an element of char *, assign '\0' instead;

6. Note that, you need to include 'string.h' in order to use memcpy.

7. memcpy prototype: memcpy(void *dest, const void * src, size_t n);
   memset prototype: memset(void *str, int c, size_t n);

Note that, memset is good for setting character to a string, but not suitable for setting an integer to an integer array.

8. remember that there are sprintf () and scanf ().

9. ASCII table has 256 characxters

9. When dealing with equation with index, double check if your equation needs "- 1".

10. Remember what palindrome and anagram means. Two strings are anagrams if their character count of each character is same for the two string. For instance, eat, ate and tea are anagram. 

11. *returnColumnSizes[i] is not right . It should be (*returnColumnSizes)[i].

12. Adjacency matrix may look easier than adjacency list, but they are really not. So, don't try to use adjacency matrix because it's easier. Besides, adjacency matrix requires looping through each element to the matrix row which cause to exceed time limit for large matrix.

13. Sometimes, a problem can be solved using graph. But, it can be solved not using graph and the version is more efficient. 

14. Sometimes, a problem can be solved using graph. and should be solved using graph. But, not really creating graph data structure. Remember the "word search" problem. Apply DFS without creating the graph.

15. Instead of checking col < num_col - 1, check if col + 1 < num_col.

16. If you need visit array for a 2D array (each element of the array is a node), create a 2D visit array, instead of a single array representing a 2D array. It produces cleaner code. (added later having single array is not bad either)

17. Think in terms of array length instead of index. This results clear code and easy to think of.

18. Instead of checking num_chars_grouped <= len - 2, check num_chars_grouped + 2 <= len.

19. For instance, you have two characters containing digits. Need to check if they corresponds to 1-26. You can check the first character and the  check if the second characters are within certain range. Instead, convert the string to its numerical value.

20. Sometimes, a problem may look like backtracking. Then look carefully if there is overlapping substructure. If there is, they can be optimized by memorization or even better can be implemented by DP. 

21. We can create zig zag pattern using two stacks.

22. Check if you can use a fixed number for stack or queue. If yes, alllocate it statically instead of dynamicly. But, implementing dynamically works fine in case you need to expand it.. (let's do that by default)

23. In min heap, each node is smaller than its chieldren. Index to the children can be found as:

                           idx1 = 2 * i + 1;//same as chield1 = 2n
                           idx2 = 2 * i + 2;//same as chield1 = 2n + 1

Again, to get the index of parent from a chield, use i = floor ((n - 1)/2); Can be implemented as i = (last_idx - 1) >> 1;

Note that, a heap is also a complete tree. A complete tree is where all the levels are completely filled except the last level. Example of banced tree is:


               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
     /  \   /
    8   7  9 

Complete tree is different from balanced tree. A balanced tree is where difference between height of left subtree and right subtree is at most one for all the nodes in the tree. For instance, these are unbalanced trees:

          4
        /   \
       3     5
      /       \
     2         6 
    /           \
   1             7

       30
      /
     20
    /
   10
Example of balanced tree is:
       4
    /    \
   2      6
 /  \    /  \
1    3  5    7 

Now, how to remove element from min-heap? remove the root. Replace the root with the last element (right most leaf). Then push down the root to maintain the heap property (also known as heapify in coremen's book, it's called bubble down in Skiena's book).

How to insert a new node to the heap? Add the new node to the end of the array (make it right most leaf). Then push it up to restore the heap properties. It is known as bubble up in Skiena's book. This is not heapify.

In heapify, first compare the two chieldren. Find the smallest children. Then compare if the node is larger than the smallest children. If yes, swap them. Note that, there can be only one children. So, implement it properly.

Given an array, how to construct a heap from that? First, find the parent to the last element. Apply heapify (bubble down) for that element and all the prior element in bottom up fashion. No need to perform bubble up.

Take a look at kth_smallest_element.c and kth_largest_stream.c.

24. If you need to compare k elements at each step to get the largest or smallest element, use min or max heap. Remember merging of k linked list or arrays..

25. char* strchar (char *str, char c) returns pointer to the first occurance of c in the str. If c does not occur, then it returns NULL.
 
26. char* strstr(char *s, char *pattern) returns pointer to the first occurance of the string pattern in string s. If pattern does not occur, it returns NULL.

27. sscanf usage:

   int day, year;
   char weekday[20], month[20], dtm[100];
   strcpy( dtm, "Saturday March 25 1989" );
   sscanf( dtm, "%s %s %d  %d", weekday, month, &day, &year );
   printf("%s %d, %d = %s\n", month, day, year, weekday );

28. There is no function called isnum() or isnumeric(). There is however isdigit(char c); 

29. parsing multiple string from a string using sscanf can be tricky. For instance,

  char s[4][20];
  int count = sscanf (IP, "%s.%s.%s.%s", &s[0][0], &s[1][0], &s[2][0], &s[3][0]);

  here, &s[0][0] gets the whole IP string.  &s[1][0], &s[2][0], &s[3][0] get garbage value. So, parse the string manually instead. 

for instance, see the following function:

bool valid_ipv4 (char * IP)
{
  int i, j, k, sum, num_dot = 0;
  int len = strlen (IP);
  
  for (i = 0, j = 0; i <= len; i++) {
    if (IP[i] == '.' || IP[i] == '\0') {
      num_dot++;
      if (i - j > 3 || i == j)
        return false;
      if (i - j >= 2 && IP[j] == '0')
        return false;
      sum = 0;
      for (k = j; k < i; k++) {
        sum = sum * 10 + (IP[k] - '0');
      }
      if (sum > 255)
        return false;
      j = i + 1;
      continue;
    }
    if (!isdigit(IP[i]))
      return false;
  }
  
  return num_dot == 4;
}

30. To implement DFS using stack, keep these in mind. 

First off, your stack may need more elements than the number of nodes. So, make the stack size twice as big as the number of nodes.

Second, you need two colors to color the visit array, not one color. When insert the first element to the stack, don't color it. In while loop, get the top of the stack (don't pop it immediately). If the ToS is colored as 1 then pop it and color as 2 (marked as visited). Otherwise, color the node with 1 (on the path). Then push all the adjacent nodes. When pushing adjacent nodes, check if the nodes have been colored yet (with 1 or 2). If the node we are inserting is 1, it means a cycle. You may add it or not depending on the application. If the node you are inserting is colored 2, that means, it's already visited and removed from the stack before. No need to add it back to stack.

Note that, when you are popping from the stack, it means backtracking. You need to add add continue (I often forget this) so that it processes the next from the stack.

Course scadule Example:

struct edge {
  int v2;
  struct edge *next;
};

bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize){
  struct edge **adj_list = (struct edge **) calloc (numCourses, sizeof (*adj_list));
  int i, j, curr;
  struct edge *new_edge;
  int *in_degrees = (int *) calloc (numCourses, sizeof (*in_degrees));
  int *visit = (int *) calloc (numCourses, sizeof (*visit));
  int *stack = (int *) malloc (numCourses * 2 * sizeof (*stack));
  int s_idx;
  struct edge *runner;
  
  for (i = 0; i < prerequisitesSize; i++) {
    new_edge = (struct edge *) malloc (sizeof (*new_edge));
    new_edge->v2 = prerequisites[i][1];
    new_edge->next = adj_list[prerequisites[i][0]];
    adj_list[prerequisites[i][0]] = new_edge;
  }
  
  for (i = 0; i < prerequisitesSize; i++) {
    in_degrees[prerequisites[i][1]]++;
  }
  
  for (i = 0; i < numCourses; i++) {
    if (visit[i] == 2)
      continue;
    s_idx = 0;
    stack[s_idx++] = i;
    while (s_idx) {
      curr = stack[s_idx - 1];
      if (visit[curr] == 1) {
        s_idx--;
        visit[curr] = 2;
        continue;
      }
      visit[curr] = 1;
      runner = adj_list[curr];
      while (runner) {
        if (visit[runner->v2] == 1)
          return false;
        //not already visited
        if (visit[runner->v2] != 2)
          stack[s_idx++] = runner->v2;
        runner = runner->next;
      }
    }
  }
  return true;
}

Added later:

This is not always the case. In some cases, in DFS, you can just pop from the stack (like DFS). For instance, number-of-islands problem can be solved using that. This is the case when you do not need to keep track of backtracking. If you need to keep track of backtracking (i.e. do sometimething during back tracking), you cannot pop from the stack immedidiately.

Added later: 

One color is very ofen fine. Just use a visit array. When you visit a node and add all adjacent node, mark it as 1 in the visit array. So, you won't expand it later. Note that, you should not mark a node just after adding to the stack. You should mark it after visit it from the stack (i.e. expanding it). Now, when you get a node from stack and it is marked, it means you are backtracking. So, simply remove it from the stack and add continue (so that you don't proceed further).

Note that sometimes, you may need to implement real backtracking algorithm in DFS. For instance, all-paths-from-source-to-target problem. In that case, you need to implement real backtracking algorithm in DFS. Recall that, in backstracking, when you backtrack, you need to unset the previous state. IN the same way, we need to unset the visit array so that DFS + Backtracking will visit previously visited node again (THis is very very interesting!!!!).

31. For instance, you want to reverse each word in  a string. Here, you should iterate from 0 to strlen(s) + 1. If i-th character is a space or NULL, then reverse the string.

32. If you are asked need to reverse a string, note that, your pointer should be i = 0, j = strlen(s). Often I take j = strlen (s) + 1.

33. For instance, You need to remove leading and trailing spaces. You also need to remove extra spaces between words. you can do it by maintaining a state variable called ignore_space. Initially it should be true. If you get a character, make it false. Again if you get a space, make it true.

34. If you print each trhiplet of an array, it should be like:

  i : 0 to len - 3
    j : i + 1 to len - 2
      k : j + 1 to len - 1

Not, 

  i : 0 to len - 1
    j : i + 1 to len -1
      k : j + 1 to len - 1

34. isalpha() checks if a char is a-z A-Z

35. Sometiomes, a problem can be solve by using two pointers and swaping element... (for instance, Sort Array By Parity). But, the problem can be also solved by quicksort partition.

Quick sort partion does the same thing in an uniform way. It also uses two indices and a pivot (usually the last element). Surprisingly, the two indices, i = -1 and j = 0. Idea is we will iterate j: 0 to n-1. Everytime arr[j] < pivot, swap (arr[++i], arr[j++]). That is, i keeps track of the left most element to which a smaller element needs to be swapped to. Finally, swap (arr[++i], arr[pivot]).

In other word, partitioning is a single pointer approach. It iterates from the first element to the last but one element. During iteration, it keeps track of the index to which a smaller element should be swapped to (represented by i). 

For details, take a look at https://www.geeksforgeeks.org/quick-sort/ 

36. if (a & 1 == 0) will not work!!!!. It should be if ((a & 1) == 0)

37. isalpha() checks if a character is an alphabet

38. It is possible to use sizeof () to calculate the amount of memory a string is consuming. But, you may get wrong results sometimes. So, you strlen instead of sizeof () to calculate the memory size of a string.

https://stackoverflow.com/questions/18525272/getting-wrong-string-length

39. Sometimes you may want to implement a circular array (e.g. hit counter problem). Mapping an element to an index of an array can be tricky. For instance, you want to access i-th element (index starts from 1) where length of the array in len. You can do so by

idx = (i - 1) % len; Not idx = (i % len) - 1.

Also iterating circular array can be tricky. for instace, you want iterate from index "start" to "end".

It should be :

for (i = start; i != end; i = (i + 1) % len) {

}

Note how we are incrementing i.
Also note how we are checking if we reached to the end. Checking if i < len will not work because if start > end, then i needs to be increase to end, then become 0 and then reach the end.

Again, for instance, you have two index i and j. You want to check if (i == j - 1), i.e. if i is the preceding element of j. You cannot do it directly because arr[len-1] is the preceeding element of arr[len-1]. To check such case, you can do this:

if ((i + 1) % len == j)

Also note that, idx_new_elem > idx_last_inserted_elem + len. That is, you are rounding the whole array. So, you may want to store that last inserted element.

40. Don't update input parameters as local variable. Create your own. It is less error prone.

41. If you need to calculate sum or multiplication of int/float, check if you need "long long" (for int) or "double" (for float) to store it. Otherwise overflow happens. If you need long long or double, also change the expression to make sure that longlong or double is stored. For instance,

int a, b;
long long sum;

sum = (long long)a + b; 

42. To print long long, using %lld. To print unsigned long long, use %llu

43. In snake ladder problem, it will be easier to solve the problem by considering each cell a number rather than a row and column. This patterns hold for many cases. If you have a 2D array, think if you can treat each cell as number instead of row col.

Sometimes, number to row-column conversion can be simplified by using slightly differnet equation. For instance, you can do the following:

  row = num / 6;
  if (num % 6 == 0)
    row--;

This can be simplified to 

  row = (num - 1) / 6;

So, if you need a special condition, check if you can find a pattern where the speacial condition goes away.

Also note that you may need to revisit the equation later if the equation works for all the cases.

44. Sometimes, in DP, I make O(n^2) solution where I could make O(n) solution (for instance house robber 1 and 2). In DP, you should not need to look much further in the DP table. You should only need to look for few previous elements to calculate the new element. If you need to look all the previous elements, double check if you could formulate DP such that that is not needed.

Note that, there are two types of DP table we saw so far.

One DP table always stores the best solution so far. It calculates the next entry based on the best solution of the current entry.

Another DP table stores the best solution using the current node. In this case, to calculate the value of a new entry, we need to iterate all the previous entry to get the best solution.

45. Sometimes, a complex problem can be break into simpler problems. Then solve the simpler problem. For instance, break the circular array of house robber II problem into two linear arrays.


46. atoi () returns 0 if convertion is not sucessful. If it returns non-zero, then conversion was sucessfull. Note that we cannot convert "0" with atoi. We need to check that manually. Note that if you pass a string "2+1+3" to atoi(), it returns 2. So, don't use to check if a string is a number or not.

47. Sometimes, you need to find all possible cases of something. You won't need backtracking. But, you can use divide and conquar to break the problem into smaller problems. Then combine the results. You can implement that using recursion. For instance, different-ways-to-add-parentheses problem.

48. abs() returns absolute value. not mod(). sqrt() calculates square root, not sqart().

49. Sometimes, in DFS and BFS, we also need to store level in a separate array than stack/queue.

50. For instance, you are given a position of a knite in chess (horse). There are 8 possible next moves of the knite. You can find all the possible next move manually by add 1/2/-1/-2... But, better approach is store those numbers in an array and calculate the next index uniformly. Example:

int nm [8][2] = {{2, 1}, {2, -1}, {-2, 1}, {-2, -1}, {1, 2}, {1, -2}, {-1, 2}, {-1, -2}};

Then add the corresponding element.

51. Sometimes, you may tend to use dynamic array to implement the visit array of DFS or BFS. But, don't do that. It causes TLE (lookup in o(n)). Figure out a way to implement array, 2D array or hash to implement the visit array so that lookup in O(1).

52. BFS does not always need queue. You may need to use heap (priority queue) instead. Specially, we need to use heap in BFS in case of A* search. Note that, in A* search, each node will also have a heuristic value. The value is calculated based on two functions: 1) How far it is from start node 2) How far it is from the destination node.

We pick up the node with the lowest heuristic value from the heap.

Note that, the heuristic functiuon can be manhatan distance (abs(x1-x2) + abs (y1-y2)) or euclidian distance (sqrt (pow (x1-x2, 2) + pow (y1-y2, 2))).
Manhantan distance is preferable if we only are allowed to go vertically or horizontally. If we are allowed to go diagonally, euclidean distance is prefereable.

Note, the Dijekstra is a special case for A* search (and BFS). Here, heuristic function only contains the distance from the start node (does not contain distance from that node to end node). In Dijekstra, we can also use a heap to extract the node with lowest weight. 


53. Sometimes, the size of the visited array of BFS/DFS or the size of the stack and queue can be inferred from the constraint. For instance, in minimum-knight-moves problem, contraint is |x| + |y| <= 300. Here, x, y are the target coordinate of the knight. From the constraint, we can assume that the size of the visit array would 605 x 605 (one for initial point. 302 in each way).

54. Sometimes greedy solution may be tempting. For instance, coin change problem. However, with few counter example, you will notice that the greedy solution will not work. Next solution would be recursion to compute all possible situation. In that, try to write a mathemetical equation on paper. This really helps. Note that, the equation may need to find minimum/maximum of an expression for all inputs. The recursion generally works because it explores all possible solution. But, the recursive solutions are exponential. So, try to solve this using DP. If the problem follows principle of optimality (i.e. soution is subproblem will be there in larger problem), you can use DP using the recursive equation. (I saw this pattern in several problem)

55. Note that in BST, you can use in order travarsal to find a predeccessor or successor of a node. You can also implement predeccessor and successor function directly. For predeccosor, go one step left, then go as much right as you can. For successor, go one step right, then go as much left as you can. Also note that in BST, we may solve a problem partially and not fully done yet. We may need to solve the same problem for other node (subtree) recursively...For instance, delete-node-in-a-bst problem. Note that, recursion here can be tricy. You are passing root of a subtree. The function will perform on the subtree and return the new root. So, you need merge the new root to the previous node. Like:
 
runner->right = deleteNode (runner->right, succ->val);

56. Note that calculating something is often more efficient than determining something. For instance, you need a list of square numbers (i.e. 1, 4, 9..) from 1 to n. I tend to solve this problem by iterating a loop from 1 to n and check if each number is a square number. This is very expensive. Rather count how many square numbers there would be (i.e. sqrt (n)) and the calculate them as 1^2, 2^2, 3^2 and so on.


57. Also note that, you cannot compare an int and float. You should consider using floar(), ceil() or using double instead. I am not sure how to do that yet. Have to look more.

58. Given two ranges: [x1:x2] and [y1:y2]. They overlap if x1 <= y2 && y1 <= x2. Yes! this is true!!!

https://stackoverflow.com/questions/3269434/whats-the-most-efficient-way-to-test-two-integer-ranges-for-overlap

https://stackoverflow.com/questions/325933/determine-whether-two-date-ranges-overlap/325964#325964

So, in summery, the ranges does not overlap if y1 > x2 || x1 > y2. So, they do not overlap if !(y1 > x2 || x1 > y2) is true.

According to, De Morgan's law, !(A  or B) = !A and !B. So, two interval will overlap if !(y1 > x2) && !(x1 > y2) is true. 
In other words, (y1 <= x2) && (x1 <= y2) is true.

Note that, here instead of checking if two intervals overlap can be very complicated. Here, we are checking if two interval does not overlap or not and that makes it way simpler.

Now, how would you find the intersection of two interval? The interval would be: start = max (x1, y1), end = min (x2, y2). Now, another way to check if two interval overlaps by checking if end >= start, if yes, they intersects. 

58. If you have interval or point, think in terms of [x1, x2] and [y1, y2]. This is easier to think about than [start1, end1] and [start2, end2]. I think, they are also easier than topleftx1, bottomrightx2, ....

59. Sometimes, you will see typical recursion (divide&conquar) is not sufficient. They generate same result twice. In that case, you need to divide the solution into two parts such that one part contains the actual solutiom and the other part is formulated in a way that repeatation is avoided. For instance, coin-change-2 problem. Try to write the recursion equation on paper. If you have an input array, also add the array in the eqation. For instance, you are given an array, arr of size m and an input n. The eqation should look like:

f(arr, m, n) = f (arr, m-1, n) + f (arr, m, n - arr[m-1])

Now, check if this can be implemeneted using DP. Note that, this may seem difficult to implement as DP because here there are two dimentions. In the left sub-part, n does not reduces, so how can you calculate value of f(arr, m, n) based on the f (arr, m-1, n)? The answer is: we need to implement DP in a different way here. First, we should assume that the length of array is 0. Then calculate the DP table. Then in the next iteration, we need to assume that length of array is 1, and update the DP array again. Then, assume that the length of array is 2 and update the DP again and so on...

https://www.geeksforgeeks.org/coin-change-dp-7/
https://leetcode.com/problems/coin-change-2/solution/

When you use DP, also write the equation on the paper. For instance, dp[i] = dp[i] + dp[i - dp[j]]; Note that, in each iteration, we are just consideing one more element (coin) than previous step. That one more element is dp[j] here.

60. Sometimes dealing with intervals, we can project start and endtime of the intervals into an array to calculate the number of overlap across different time (e.g. meeting-rooms-ii). 

61. Sometimes, problem will give you diffeerent interval and ask how many meeting rooms will you need to accomodate the interval. The problem may sound like backtracking or greedy approach (e.g. meeting-rooms-ii). But, if you think carefully, you will see that this is same as asking the maximum number of overlapping intervals.

62. Note that, sometimes the problem may seem and is very hard. You can always find the brutforce solution. That involves having several loop or recursion. For instance, maximum-profit-in-job-scheduling or weighted-job-scheduling problem.  
 
Now, always write the recursive equation on the paper!!!

Then check if this eqation can be implemented as DP. If yes, implement that. keep in mind that DP always works like magic. The code is simple. And it works!!! Have faith and don't panic :-) The code most of the time works in the first few attempts.

63. Sometimes, you cannot draw points using traditional X-Y axis. Sometimes, the element at position is not on the points rather they are on the space between two points. For instance, trapping-rain-water problem. In that case, you need to number the space between two poaints rather the points.

For instance, instead of doing:

----|------|-----|------|-------------
    1      2     3      4

Do this:

----|------|-----|------|-------------
 1      2     3      4

64. Note that, there are fmin(), fmax() that can calculate min/max, however they are in cmath header (C++)

65. char *strcat(char *dest, const char *src)

Here, it appends src to dest. Note that, dest has to be large enough to store the appended string. This is very similar to sprintf ();

I would use sprinf() instead. 

Here, is an examle of strcat().

   char src[50], dest[50];

   strcpy(src,  "This is source");
   strcpy(dest, "This is destination");

   strcat(dest, src);

   printf("Final destination string : |%s|", dest);

66. Always initialize a pointer/string if you are not sure if it will always be assigned before use. You may think that you will add it later if needed. But, doing it in the first place doesn't do any harm and saves a lot of debug time.

67. A catch!!!!!!!

This is fine..
 
sprintf (out, "%s %s", out, str);

This is not!!!

sprintf (out, "%s %s", str, out);

This will produce "str str"!!! You can use another string or use strcat..., but don't do that! Write the logic in a way that you pass out as the first parameter!!!!!

68. Sometimes, logic requires like (e.g. integer-to-english-words problem):

sprintf (out, "%s%s%s", empty ? "" : out, empty ? "" : " ", str);

This makes it complicated. Try to write the logic using if-else... Like..

  if (ten) {
    sprintf (out, "%s", ten_str);
    if (one) {
      sprintf (out, "%s %s", out, one_str);
    }
  } else {
    sprintf (out, "%s", one_str);
  }

69. Sometimes it's nice to write comment in code while coding...

    if (end)
      break;
    //Reverse nodes from runner1 to runner2
    runner2 = runner1->next;

70. When writting iterator for linked list, use runner1, runner2, runner3... in code, but write r1, r2, r3..on paper. Don't use names like prev_node or temp node...even though you are using them as temp (actually this is more of my habit..)

71. Sometime linked list problem get TLE because program  does not set the next of the last node to NULL. Remember to set the next of the last node to NULL.

72. Anytime, you need to check if the index is >= 0 or < arr_length, always check like idx + 1 < arr_len or idx - 1 >= 0. I tend to check with idx which makes it complicated!!!! Keep this in mind. You will do it even though you think you wont :-)

73. Sometimes, solving a problem in a human way is very complex. First step is to find an intuitation to solve the problem. Sometimes, going to solve the intuition can be very difficult. For instance, trapping-rain-water problem. Instead of solving the problem for the whole space, try to solve it for a point in the space. If we can do it, solving for the whole speace is just repeating for each point. So, if a problem looks too dificult, see if you can solve the problem for a point of the problem space.

74. Also note that sometimes, an equation can be simpler when you have min/max in your equation. For instance, in trapping-rain-water problem, you need to know the maximum to the left and maximum to the right. In reality, this is not the case. But,as we take minimum of the two, our equation is still valid. 

75. Sometimes, you may inclined to represent intervals as :

----|------|-----|------|-------------
 1      2     3      4

But, you shouldn't! You should represent it as:

----|------|-----|------|-------------
    1      2     3      4

76. Also note that, although an interval is represented as [x, y], it is really [x, y)

77. Remember that, in some case, in DFS, you may want to set visit to false again in case of backtracking. For instance, word-search.

78. Note that, in DFS, when adding adjacent nodes to the stack, check if they are already visited.

79. Sometimes, in DFS, before adding adjacent node to the stack, you can check if you really should add it. For instance, in word-search problem, you know the next letter you will be looking for. So, if the adjacent node is not the next letter, you don't really need to add it. 

Note that, this is same as performing DFS recursively like flood water problem (At each node, we make recursive call on adjacent node). If adjacent node is not the next expecting node, we don't need to make the call. Also node that, here, we pass the visit array as a function parameter or global array so that all the recursive call gets the latest value of the visit array (passing as parameter is preferable). 

80. Trie node:

struct trie_node {
  bool leaf;//not really a leaf. It should be end-of-word
  struct trie_node *child[26];
};

Note that, trie node may not need value, because select the index to the next node based on the value. The root of of trie is often empty. This is how a trie looks like:

           root
           / | \
         c/  |b \a
         /   |   \
       node node node
       / | \
     c/  |b \a
     /   |   \
  node node node

81. Sometimes, we may need to travarse tree/trie while performing DFS in another graph (e.g. word-search-ii). It is easier to merge the recursive solution of tree travarsal and DFS.

82. While visiting Trie, we also need an array that keeps track of the string of the corresponding node.

83. When copying output to res (pointer), make sure that they are allocated in memory. Sometimes, you may just want to return pointer. You don't need to allocate memory in that case.

84. Don't forget to check nengivate condition first and then continue or return. If you proceed, that means you find a positive case. This requires fewer nested indentation.

85. Don't use *ret_size because it may not initialized properly. Use your own res_cnt. Then update *ret_size.

86. When inserting multiple strings to a trie, don't create a node if it already exists. That's the point of trie. But, I often create node for each character in each string.

87. Merging the intervals by projecting them on an array is an efficient solution. But, if each interval is very large, this may not be a good solution. You may want to merge the intervals manually in that case. You want to sort the intervals by start time in that case.

https://www.geeksforgeeks.org/merging-intervals/

88. Some problems are conventionally known as DP. You can also implement via recursion with memoraziation. For intsnace, in word-break problem, you can encode a dictionary with a trie. But, Trie search may need to make recursive call on a subproblem when you reach a node that denotes end of a word. This is because this node may not a leaf. So, you may want look further. So, the psudocode is like:

call search for the rest of the subproblem. If it returns true, then return true. Otherwise, proceed to the child of the current node.

This recursive call many same subproblem when trie is like:

   root
    |
    |a
    |
   node
    |
    |a
    |
   node
    |
    |a
    |
   node

For instance, if input is aaab, it will call search function for aaab, aab, ab, a, b, b, ab...


https://www.geeksforgeeks.org/word-break-problem-dp-32/

https://www.geeksforgeeks.org/word-break-problem-trie-solution/

This problem can be solved using memorization. So, if you solve a problem once, save the result. This may look trivial.but don't do it!!!!!!!


Yes, don't do it!!!!!! Once you figure how to use recursion, try to figure DP. It's way ceasier. And way easier to implement!! Yes, it's way easier to implement!!! So, don't try to implement a DP problem with recursion!!!!! DP is way easier.

89. Sometimes, I may send different pointer when making recursive call. Like: 

trie_search (root, &s[i+1], mem);

Don't do it! Do this instead:

trie_search (root, s, i+1, mem);

90. Sometimes, you may be asked to produce all combination of something. You need to know that finding all combination of something requires you to identify something first. For instance, in word-break-ii, you are asked to find all the ways you can break a string according to a dictionary. To solve the problem, we can solve word-break first, then use that to find all the combinations.

Now, if you do this, it will be very overly complicated. I may think this way, but there is a better way. try to find algorithm in fresh mind.

Note that, when you are asked to find all combinations, it's generally backtracking algorithm. So, try to use backtracking...

Note that, backtracking can also be think of as recursion or DFS. Sometimes, you may have an array. You may think you need to implemenet DFS/BFS on the array, but, they can be implemented as recursion (aka DFS). For instance, word-break-ii

Now, note that, anytime you have a recursive solution, check if there is overlapping subproblems. This tend to be very expensive. If there can be overlapping subproblems, implemenet them using DP. Besides, DP is a lot more easier than implementing recursion. In recursion, you are taking a complex problem, and dividing into smaller problem (top-down). On the other hand, in DP, you are starting with a smaller problem, and solving the bigger problem with smaller problem (bottom-up). This tend to be way easier!!!!!!!!

91. When iterating a trie using runner, if you find a match, you should move the runner to the next node immediately because that's the actual node. Then you can check if that node denotes the end of a word.

92. If you want to create a substring from a string, you can use memcpy() or strncpy().

strncpy(char* dest, char* src, int n) is from <cstring>.

Also note that if you use memcpy(), be sure to add NULL manually.

93. Sometimes you may need list of string. You don't have vector in C. So, what you do is have large ***str_list. Allocate them dynamically and use them like an array. This is not much difficult to do compared to vector. Only problem is you need to be aware to pre-allocate as much memory as you might need.

94. It can be more convinient to try to solve a problem based on bottom up approach. This is actaully DP. This actually way easier. A lot complicated problem can become surprisingly simple if you think in bottom up approach. For instance, count-of-range-sum.. So, think bottom up!!!!!!

95. When DPing half of a 2D array in diagonal mannager, use row, col for index along with i. For instance,

  for (i = 1; i < numsSize; i++) {
    for (row = 0, col = i; col < numsSize; row++, col++) {
      idx = row * numsSize + col;
      dp[idx] = dp[idx - 1] + nums[col];
    }
  }

Here, we are filling top-right part of the matrix.

95. How a negative number is stored in computer? It's store in two's complement format. For instance, 4 = 100. -4 = 1111111...1100 (one's complement is 11..1011. two's complement is 11..1100)

Again, 20 = 10100. -20 = 111...01100. 

So, there are several lessons:

a. If a number starts with 1, it's a negative number.
b. Content of a positive and negative number may differ in more than just sign field (MSB).
c. If a number is power of two, it's positive and negative number will only differ in signfield (and 111)
d. You can unset the right-most set bit by n - (n & -n). This is used in Binary index tree to calculate index to the parent.

On a similar note, n & (n - 1) unsets right-most set bit.

https://www.geeksforgeeks.org/binary-indexed-tree-or-fenwick-tree-2/


So, basicly, two's complement store the same number

96. If you are asked to develop range sum, you should ask if the array is immutatble. If the array is immutatble, the create prefix sum. Then, you can calculate any range sum at O(1). 

But, if the array is not mutable, then you need to create Binary Index Tree (BIT). BIT supports range query and update at O (logn). You can also use merge sort to implement this. Merge sort is more efficient, i think.

97. Sometimes, it's ok to create an array that is 1 eleenet larger (1 based array) if that makes the logic simpler.

98. In merge sort, you can merge two arrays in place. This is more efficient. But, sometimes, you may need to implement additional logic. It's OK to use an extra array to merge two arrays and implement that logic if that make the logic simpler (counting the number of smaller elements to the right). 

99. Sometimes, itrating array forward to caluclate O(n) while iterating the array backwords needs O(1). For instance, merging two arrays to calculate the number of smaller elements to the right, iterating array from the right allows us to caluclate the number at O(1). 

100. In merge sort, you can pass a preallocated temp array so that you don't need to alloccate a new array in every recursive call. Also note that this can be more efficient way of merging because merging two sorted arrays in place is not linear while this is. 

101. Suppose you have two sorted arrays A and B. You need to find the number of pairs such that lower <= B[j] - A[i] <= upper. We came across this problem in count-of-range-sum problem. 

Here, we will maintain a variable lo which indicates the index to the first element B for which B[lo] - A[i] >= lower for an iteration. Note that lo is not initialized to 0 in each iteration. It rather starts from where it stopped in the last iteration. We can do this because A is sorted. So, elemements to the left of lo will produce even lower B[j] - A[i] for the next element of A.

Algorithm:

  lo = 0;
  for (i = 0; i < A_len; i++) {
    while (lo < B_len && B[lo] - A[i] < lower)
      lo++;
    for (j = lo; j < B_len; j++) {
      if (B[j] - A[i] <= upper)
        count++;
      else
        break;//Once we reach an element where difference is larger than the upper, no need to go further because the differtence will increase
    }
  }

102. Sometimes, long is not enough. You need long long specially when multiplying by 2.. Note that, you can compare an int and long long. So, when comparing two variables, both does not have to be the same type. 

Also keep in mind that changing variable type to long long from int does not help by itself. You also need to perform casting in the original operation. For instance:

tmp = (long long)nums[j] * 2;

103. Note that, left-shift and right shift of negative number is undefined. So, don't use them if the number can be negative. Instead multiply by 2 or 5 or use division.... (plain old)


104. You don't really need a temporary long long variable. You can just cast in-place and compare. For intance:

if ((long long)nums[hi] * 2 >= nums[i]) is fine!!!!

105. Suppose, in merge sort approach, you often need to compute something based on two sorted arrays. For instance, in reverse-pairs problem, you will have two sorted arrays A and B. You need to count the number of pairs for which B[j] * 2 > A[i].

You can do this by following code:

  int hi = end;//only need to initialize once. In next iteration, start from when we stopped 
  for (i = mid; i >= start; i--) {
    while (hi >= mid + 1 && (long long)nums[hi] * 2 >= nums[i])
      hi--;
    if (hi >= mid + 1)
      *count += (hi - mid);
  }

106. Sometime, we iterate from i: 1-n to move each element one step left and insert a new element. Note that if array size is 1, this loop will not enter at all. Need to keep in mind to write the moving logic

107. Sometimes, you will be asked if you can solve the problem without using a hash-map. One solution is to use the input array as hash. For instance. if an element is seen, you can make the corresponding (original) array element negative. Thus negative element will indicate if the number has been seen or not. For instance, find-all-numbers-disappeared-in-an-array problem.

108. Sometimes, don't be too quick to judge between stack or queue. Play a simulation. Sometimes, it seems you need a queue, but you really need a stack..

109. When grouping string or list, check that if need to sort them first. For instance, when making group of anagrams, you don't need to check strings with different lengths. So, sorting the string first helps!!!

110. Don't use itoa() to convert int to char*. Use sprintf () instead.

111. When sorting a 2D arry using qsort (), you need to pass the size of the pointer instead of the size of the internal array. For instance, 

  char **num_str = (char **) malloc (numsSize * sizeof (*num_str));
  for (i = 0; i < numsSize; i++) {
    num_str[i] = (char *) calloc (12, sizeof (char));
    sprintf (num_str[i], "%d", nums[i]);
  }

  The qsort should look like:

qsort (num_str, numsSize, sizeof (char *), cmp);

It should not look like!!!!:

qsort (num_str, numsSize, 12 * sizeof (char), cmp);

Also, in this case: the cmp will be passed char**. So, it should look like:

int cmp (const void *a, const void *b)
{
  int i, j;
  char *num1 = *((char **)a);
  char *num2 = *((char **)b);
 .......
}

Not :

int cmp (const void *a, const void *b)
{
  int i, j;
  char *num1 = (char *)a;
  char *num2 = (char *)b;
 .......
}

Keep this in mind about cmp:

int cmp(const void* p1, const void* p2);
Return value meaning
<0 The element pointed by p1 goes before the element pointed by p2
0  The element pointed by p1 is equivalent to the element pointed by p2
>0 The element pointed by p1 goes after the element pointed by p2



112. When comparing character, I often forget '' more specially if the character is a digit. For instance, do ch == '0', not ch == 0


113. Note that, strcpy () is strcpy (char *dst, char *src). It does not need size of the string like memcpy. I often add an extra parameter string len * sizeof (char) which is not right.

114. Sometimes, implementing a logic can be too complicated. We can make it simple by creating extra data structure and compare them. For instance, in largest-number problem, we have two strings: x and y and we need to determine if xy > yx..

One solution is two have two pointers one pointing x and another pointing y..At each iteration we compare the value of the pointer. If the values are not the same, we get our answer. When the first pointer reach the end of x, make it to point y. In the same way, when the second pointer reach the end of y, make it point to the x.... But, this logic can be still compilcated to decide which one is better.

Another simpler solution is to just create xy and yx string and compare them. 


The first approach is obviously better, but the second approach is simpler!

115. Binary Subtraction:
0 – 0 = 0
1 – 0 = 1
1 – 1 = 0
0 – 1 = 1 (Borrow 1)

1011 - 11
0100 - 4
-----------
0111 - 7

115. To return a negative of a variable, we can do this: "return -a;" No need to do "return a * -1;"

116. In do-while loop, I forget semicolon after while. It should be:

do {

} while ();

117. If you need to perform bitwise operation, the operand cannot be negative. Make them positive by abs() and handle negative and positive values separately.


118. I often get confused with Xor (^) operation. I feel like preceeding 0s of a number will produce preceeding 1s in the result. But, actually preceeding 0s creates preceeding 0s in the result because 0 ^ 0 = 0.

119. if (!head || !(head->next)) is fine. We don't need to write if (!head || (head && !(head->next)))

Right side of the || will only execute if !head is false 

120. Sometimes, it ,may seem that initiazing to sometihing to -1 makes more sense than initializing to 0. Think hard if this is really the case. I often find later that initializing to 0 is just fine and works even better. Implementation is often simpler.

On an another note, sometimes, it may seem that storing partial result - 1 is more convinient and then get the final result by partial result + 1. But, this is often unnecessary. In many cases, I found that storing the actual result is just fine.

121. When doing DFS, think if you need to visit a previously visited node again. It depends on the application. Sometimes, you may want to backtrack and visit a previously visited node. In that case, when backtracking, you need to set visit[node] = 0 while backtracking. 

122. Sometimes, iterative implementation of DFS/BFS can be too difficult. You may consider recursive implementation. For instance, longest-increasing-path-in-a-matrix problem. I came across similar issues before.

Sometimes, iterative implementation is not adequete at all!!!! For instance, think about a situation where you need to make a decision based on different branches of DFS. For instance, in longest-increasing-path-in-a-matrix problem, we need to keep track of longest path originating from each node. That is, we need to handle multiple braches at each node and then make decision on the branches. Iterative solution will simply iterarte nodes of each brach one at a time. Although it can detect backtracking, but it's hard to track where we are staring to visit aother brach... Implementing longest-increasing-path-in-a-matrix in iterative mode is very hard to implement. On the other hand, it's switable to be implemented using recursive approach because recursive approach handle multiple branches separately and then process themm...

123. If your input is a matrix, don't use 1-D array for visit or string anything. It may seem convinient, but believe me, it will make the code look uglier later. Instead create a 2D matrix. It's also easy to implement and produces easier code.
