1. To include "match.h", need to use -lm to compile

2. In backtracking algorithms, the inner algorithm should not return anything. The inner algorithm should return the outout as input.

3. cmp in qsort():

int cmp (const void *a, const void *b)
{
  return *((int *)a) - *((int *)b);
}

3. qsort prototype: qsort(arr, len, sizeof(arr[0]), cmp);

4. When returning char *, note that char * should also include '\0'. So, when allocating it, allocate one character extra.

5. when assigning NULL to an element of char *, assign '\0' instead;

6. Note that, you need to include 'string.h' in order to use memcpy.

7. memcpy prototype: memcpy(void *dest, const void * src, size_t n);
   memset prototype: memset(void *str, int c, size_t n);

Note that, memset is good for setting character to a string, but not suitable for setting an integer to an integer array.

8. remember that there are sprintf () and scanf ().

9. ASCII table has 256 characxters

9. When dealing with equation with index, double check if your equation needs "- 1".

10. Remember what palindrome and anagram means. Two strings are anagrams if their character count of each character is same for the two string. For instance, eat, ate and tea are anagram. 

11. *returnColumnSizes[i] is not right . It should be (*returnColumnSizes)[i].

12. Adjacency matrix may look easier than adjacency list, but they are really not. So, don't try to use adjacency matrix because it's easier. Besides, adjacency matrix requires looping through each element to the matrix row which cause to exceed time limit for large matrix.

13. Sometimes, a problem can be solved using graph. But, it can be solved not using graph and the version is more efficient. 

14. Sometimes, a problem can be solved using graph. and should be solved using graph. But, not really creating graph data structure. Remember the "word search" problem. Apply DFS without creating the graph.

15. Instead of checking col < num_col - 1, check if col + 1 < num_col.

16. If you need visit array for a 2D array (each element of the array is a node), create a 2D visit array, instead of a single array representing a 2D array. It produces cleaner code.

17. Think in terms of array length instead of index. This results clear code and easy to think of.

18. Instead of checking num_chars_grouped <= len - 2, check num_chars_grouped + 2 <= len.

19. For instance, you have two characters containing digits. Need to check if they corresponds to 1-26. You can check the first character and the  check if the second characters are within certain range. Instead, convert the string to its numerical value.

20. Sometimes, a problem may look like backtracking. Then look carefully if there is overlapping substructure. If there is, they can be optimized by memorization or even better can be implemented by DP. 

21. We can create zig zag pattern using two stacks.

22. Check if you can use a fixed number for stack or queue. If yes, alllocate it statically instead of dynamicly.

23. In min heap, each node is smaller than its chieldren. Index to the children can be found as:

                           idx1 = 2 * i + 1;//same as chield1 = 2n
                           idx2 = 2 * i + 2;//same as chield1 = 2n + 1

Again, to get the index of parent from a chield, use i = floor ((n - 1)/2); Can be implemented as i = (last_idx - 1) >> 1;

Note that, a heap is also a complete tree. A complete tree is where all the levels are completely filled except the last level. Example of banced tree is:


               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
     /  \   /
    8   7  9 

Complete tree is different from balanced tree. A balanced tree is where difference between height of left subtree and right subtree is at most one for all the nodes in the tree. For instance, these are unbalanced trees:

          4
        /   \
       3     5
      /       \
     2         6 
    /           \
   1             7

       30
      /
     20
    /
   10
Example of balanced tree is:
       4
    /    \
   2      6
 /  \    /  \
1    3  5    7 

Now, how to remove element from min-heap? remove the root. Replace the root with the last element (right most leaf). Then push down the root to maintain the heap property (also known as heapify in coremen's book, it's called bubble down in Skiena's book).

How to insert a new node to the heap? Add the new node to the end of the array (make it right most leaf). Then push it up to restore the heap properties. It is known as bubble up in Skiena's book. This is not heapify.

In heapify, first compare the two chieldren. Find the smallest children. Then compare if the node is larger than the smallest children. If yes, swap them. Note that, there can be only one children. So, implement it properly.

Given an array, how to construct a heap from that? First, find the parent to the last element. Apply heapify (bubble down) for that element and all the prior element in bottom up fashion. No need to perform bubble up.

Take a look at kth_smallest_element.c and kth_largest_stream.c.

24. If you need to compare k elements at each step to get the largest or smallest element, use min or max heap. Remember merging of k linked list or arrays..

25. char* strchar (char *str, char c) returns pointer to the first occurance of c in the str. If c does not occur, then it returns NULL.
 
26. char* strstr(char *s, char *pattern) returns pointer to the first occurance of the string pattern in string s. If pattern does not occur, it returns NULL.

27. sscanf usage:

   int day, year;
   char weekday[20], month[20], dtm[100];
   strcpy( dtm, "Saturday March 25 1989" );
   sscanf( dtm, "%s %s %d  %d", weekday, month, &day, &year );
   printf("%s %d, %d = %s\n", month, day, year, weekday );

28. There is no function called isnum(). There is however isdigit(char c); 

29. parsing multiple string from a string using sscanf can be tricky. For instance,

  char s[4][20];
  int count = sscanf (IP, "%s.%s.%s.%s", &s[0][0], &s[1][0], &s[2][0], &s[3][0]);

  here, &s[0][0] gets the whole IP string.  &s[1][0], &s[2][0], &s[3][0] get garbage value. So, parse the string manually instead. 

for instance, see the following function:

bool valid_ipv4 (char * IP)
{
  int i, j, k, sum, num_dot = 0;
  int len = strlen (IP);
  
  for (i = 0, j = 0; i <= len; i++) {
    if (IP[i] == '.' || IP[i] == '\0') {
      num_dot++;
      if (i - j > 3 || i == j)
        return false;
      if (i - j >= 2 && IP[j] == '0')
        return false;
      sum = 0;
      for (k = j; k < i; k++) {
        sum = sum * 10 + (IP[k] - '0');
      }
      if (sum > 255)
        return false;
      j = i + 1;
      continue;
    }
    if (!isdigit(IP[i]))
      return false;
  }
  
  return num_dot == 4;
}

30. To implement DFS using stack, keep these in mind. 

First off, your stack may need more elements than the number of nodes. So, make the stack size twice as big as the number of nodes.

Second, you need two colors to color the visit array, not one color. When insert the first element to the stack, don't color it. In while loop, get the top of the stack (don't pop it immediately). If the ToS is colored as 1 then pop it and color as 2 (marked as visited). Otherwise, color the node with 1 (on the path). Then push all the adjacent nodes. When pushing adjacent nodes, check if the nodes have been colored yet (with 1 or 2). If the node we are inserting is 1, it means a cycle. You may add it or not depending on the application. If the node you are inserting is colored 2, that means, it's already visited and removed from the stack before. No need to add it back to stack.

Note that, when you are popping from the stack, it means backtracking. You need to add add continue (I often forget this) so that it processes the next from the stack.

Course scadule Example:

struct edge {
  int v2;
  struct edge *next;
};

bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize){
  struct edge **adj_list = (struct edge **) calloc (numCourses, sizeof (*adj_list));
  int i, j, curr;
  struct edge *new_edge;
  int *in_degrees = (int *) calloc (numCourses, sizeof (*in_degrees));
  int *visit = (int *) calloc (numCourses, sizeof (*visit));
  int *stack = (int *) malloc (numCourses * 2 * sizeof (*stack));
  int s_idx;
  struct edge *runner;
  
  for (i = 0; i < prerequisitesSize; i++) {
    new_edge = (struct edge *) malloc (sizeof (*new_edge));
    new_edge->v2 = prerequisites[i][1];
    new_edge->next = adj_list[prerequisites[i][0]];
    adj_list[prerequisites[i][0]] = new_edge;
  }
  
  for (i = 0; i < prerequisitesSize; i++) {
    in_degrees[prerequisites[i][1]]++;
  }
  
  for (i = 0; i < numCourses; i++) {
    if (visit[i] == 2)
      continue;
    s_idx = 0;
    stack[s_idx++] = i;
    while (s_idx) {
      curr = stack[s_idx - 1];
      if (visit[curr] == 1) {
        s_idx--;
        visit[curr] = 2;
        continue;
      }
      visit[curr] = 1;
      runner = adj_list[curr];
      while (runner) {
        if (visit[runner->v2] == 1)
          return false;
        //not already visited
        if (visit[runner->v2] != 2)
          stack[s_idx++] = runner->v2;
        runner = runner->next;
      }
    }
  }
  return true;
}

31. For instance, you want to reverse each word in  a string. Here, you should iterate from 0 to strlen(s) + 1. If i-th character is a space or NULL, then reverse the string.

32. If you are asked need to reverse a string, note that, your pointer should be i = 0, j = strlen(s). Often I take j = strlen (s) + 1.

33. For instance, You need to remove leading and trailing spaces. You also need to remove extra spaces between words. you can do it by maintaining a state variable called ignore_space. Initially it should be true. If you get a character, make it false. Again if you get a space, make it true.

34. If you print each trhiplet of an array, it should be like:

  i : 0 to len - 3
    j : i + 1 to len - 2
      k : j + 1 to len - 1

Not, 

  i : 0 to len - 1
    j : i + 1 to len -1
      k : j + 1 to len - 1

34. isalpha() checks if a char is a-z A-Z

35. Sometiomes, a problem can be solve by using two pointers and swaping element... (for instance, Sort Array By Parity). But, the problem can be also solved by quicksort partition.

Quick sort partion does the same thing in an uniform way. It also uses two indices and a pivot (usually the last element). Surprisingly, the two indices, i = -1 and j = 0. Idea is we will iterate j: 0 to n-1. Everytime arr[j] < pivot, swap (arr[++i], arr[j++]). That is, i keeps track of the left most element to which a smaller element needs to be swapped to. Finally, swap (arr[++i], arr[pivot]).

In other word, partitioning is a single pointer approach. It iterates from the first element to the last but one element. During iteration, it keeps track of the index to which a smaller element should be swapped to (represented by i). 

For details, take a look at https://www.geeksforgeeks.org/quick-sort/ 

36. if (a & 1 == 0) will not work!!!!. It should be if ((a & 1) == 0)

37. isalpha() checks if a character is an alphabet

38. It is possible to use sizeof () to calculate the amount of memory a string is consuming. But, you may get wrong results sometimes. So, you strlen instead of sizeof () to calculate the memory size of a string.

https://stackoverflow.com/questions/18525272/getting-wrong-string-length

39. Sometimes you may want to implement a circular array (e.g. hit counter problem). Mapping an element to an index of an array can be tricky. For instance, you want to access i-th element (index starts from 1) where length of the array in len. You can do so by

idx = (i - 1) % len; Not idx = (i % len) - 1.

Also iterating circular array can be tricky. for instace, you want iterate from index "start" to "end".

It should be :

for (i = start; i != end; i = (i + 1) % len) {

}

Note how we are incrementing i.
Also note how we are checking if we reached to the end. Checking if i < len will not work because if start > end, then i needs to be increase to end, then become 0 and then reach the end.

40. Don't update input parameters as local variable. Create your own. It is less error prone.


