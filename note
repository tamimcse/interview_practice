1. To include "match.h", need to use -lm to compile

2. In backtracking algorithms, the inner algorithm should not return anything. The inner algorithm should return the outout as input.

3. cmp in qsort():

int cmp (const void *a, const void *b)
{
  return *((int *)a) - *((int *)b);
}

3. qsort prototype: qsort(arr, len, sizeof(arr[0]), cmp);

4. When returning char *, note that char * should also include '\0'. So, when allocating it, allocate one character extra.

5. when assigning NULL to an element of char *, assign '\0' instead;

6. Note that, you need to include 'string.h' in order to use memcpy.

7. memcpy prototype: memcpy(void *dest, const void * src, size_t n);
   memset prototype: memset(void *str, int c, size_t n);

Note that, memset is good for setting character to a string, but not suitable for setting an integer to an integer array.

8. remember that there are sprintf () and scanf ().

9. ASCII table has 256 characxters

9. When dealing with equation with index, double check if your equation needs "- 1".

10. Remember what palindrome and anagram means. Two strings are anagrams if their character count of each character is same for the two string. For instance, eat, ate and tea are anagram. 

11. *returnColumnSizes[i] is not right . It should be (*returnColumnSizes)[i].

12. Adjacency matrix may look easier than adjacency list, but they are really not. So, don't try to use adjacency matrix because it's easier. Besides, adjacency matrix requires looping through each element to the matrix row which cause to exceed time limit for large matrix.

13. Sometimes, a problem can be solved using graph. But, it can be solved not using graph and the version is more efficient. 

14. Sometimes, a problem can be solved using graph. and should be solved using graph. But, not really creating graph data structure. Remember the "word search" problem. Apply DFS without creating the graph.

15. Instead of checking col < num_col - 1, check if col + 1 < num_col.

16. If you need visit array for a 2D array (each element of the array is a node), create a 2D visit array, instead of a single array representing a 2D array. It produces cleaner code. (added later having single array is not bad either)

17. Think in terms of array length instead of index. This results clear code and easy to think of.

18. Instead of checking num_chars_grouped <= len - 2, check num_chars_grouped + 2 <= len.

19. For instance, you have two characters containing digits. Need to check if they corresponds to 1-26. You can check the first character and the  check if the second characters are within certain range. Instead, convert the string to its numerical value.

20. Sometimes, a problem may look like backtracking. Then look carefully if there is overlapping substructure. If there is, they can be optimized by memorization or even better can be implemented by DP. 

21. We can create zig zag pattern using two stacks.

22. Check if you can use a fixed number for stack or queue. If yes, alllocate it statically instead of dynamicly. But, implementing dynamically works fine in case you need to expand it.. (let's do that by default)

23. In min heap, each node is smaller than its chieldren. Index to the children can be found as:

                           idx1 = 2 * i + 1;//same as chield1 = 2n
                           idx2 = 2 * i + 2;//same as chield1 = 2n + 1

Again, to get the index of parent from a chield, use i = floor ((n - 1)/2); Can be implemented as i = (last_idx - 1) >> 1;

Note that, a heap is also a complete tree. A complete tree is where all the levels are completely filled except the last level. Example of banced tree is:


               18
           /       \  
         15         30  
        /  \        /  \
      40    50    100   40
     /  \   /
    8   7  9 

Complete tree is different from balanced tree. A balanced tree is where difference between height of left subtree and right subtree is at most one for all the nodes in the tree. For instance, these are unbalanced trees:

          4
        /   \
       3     5
      /       \
     2         6 
    /           \
   1             7

       30
      /
     20
    /
   10
Example of balanced tree is:
       4
    /    \
   2      6
 /  \    /  \
1    3  5    7 

Now, how to remove element from min-heap? remove the root. Replace the root with the last element (right most leaf). Then push down the root to maintain the heap property (also known as heapify in coremen's book, it's called bubble down in Skiena's book).

How to insert a new node to the heap? Add the new node to the end of the array (make it right most leaf). Then push it up to restore the heap properties. It is known as bubble up in Skiena's book. This is not heapify.

In heapify, first compare the two chieldren. Find the smallest children. Then compare if the node is larger than the smallest children. If yes, swap them. Note that, there can be only one children. So, implement it properly.

Given an array, how to construct a heap from that? First, find the parent to the last element. Apply heapify (bubble down) for that element and all the prior element in bottom up fashion. No need to perform bubble up.

Take a look at kth_smallest_element.c and kth_largest_stream.c.

24. If you need to compare k elements at each step to get the largest or smallest element, use min or max heap. Remember merging of k linked list or arrays..

25. char* strchar (char *str, char c) returns pointer to the first occurance of c in the str. If c does not occur, then it returns NULL.
 
26. char* strstr(char *s, char *pattern) returns pointer to the first occurance of the string pattern in string s. If pattern does not occur, it returns NULL.

27. sscanf usage:

   int day, year;
   char weekday[20], month[20], dtm[100];
   strcpy( dtm, "Saturday March 25 1989" );
   sscanf( dtm, "%s %s %d  %d", weekday, month, &day, &year );
   printf("%s %d, %d = %s\n", month, day, year, weekday );

28. There is no function called isnum() or isnumeric(). There is however isdigit(char c); 

29. parsing multiple string from a string using sscanf can be tricky. For instance,

  char s[4][20];
  int count = sscanf (IP, "%s.%s.%s.%s", &s[0][0], &s[1][0], &s[2][0], &s[3][0]);

  here, &s[0][0] gets the whole IP string.  &s[1][0], &s[2][0], &s[3][0] get garbage value. So, parse the string manually instead. 

for instance, see the following function:

bool valid_ipv4 (char * IP)
{
  int i, j, k, sum, num_dot = 0;
  int len = strlen (IP);
  
  for (i = 0, j = 0; i <= len; i++) {
    if (IP[i] == '.' || IP[i] == '\0') {
      num_dot++;
      if (i - j > 3 || i == j)
        return false;
      if (i - j >= 2 && IP[j] == '0')
        return false;
      sum = 0;
      for (k = j; k < i; k++) {
        sum = sum * 10 + (IP[k] - '0');
      }
      if (sum > 255)
        return false;
      j = i + 1;
      continue;
    }
    if (!isdigit(IP[i]))
      return false;
  }
  
  return num_dot == 4;
}

30. To implement DFS using stack, keep these in mind. 

First off, your stack may need more elements than the number of nodes. So, make the stack size twice as big as the number of nodes.

Second, you need two colors to color the visit array, not one color. When insert the first element to the stack, don't color it. In while loop, get the top of the stack (don't pop it immediately). If the ToS is colored as 1 then pop it and color as 2 (marked as visited). Otherwise, color the node with 1 (on the path). Then push all the adjacent nodes. When pushing adjacent nodes, check if the nodes have been colored yet (with 1 or 2). If the node we are inserting is 1, it means a cycle. You may add it or not depending on the application. If the node you are inserting is colored 2, that means, it's already visited and removed from the stack before. No need to add it back to stack.

Note that, when you are popping from the stack, it means backtracking. You need to add add continue (I often forget this) so that it processes the next from the stack.

Course scadule Example:

struct edge {
  int v2;
  struct edge *next;
};

bool canFinish(int numCourses, int** prerequisites, int prerequisitesSize, int* prerequisitesColSize){
  struct edge **adj_list = (struct edge **) calloc (numCourses, sizeof (*adj_list));
  int i, j, curr;
  struct edge *new_edge;
  int *in_degrees = (int *) calloc (numCourses, sizeof (*in_degrees));
  int *visit = (int *) calloc (numCourses, sizeof (*visit));
  int *stack = (int *) malloc (numCourses * 2 * sizeof (*stack));
  int s_idx;
  struct edge *runner;
  
  for (i = 0; i < prerequisitesSize; i++) {
    new_edge = (struct edge *) malloc (sizeof (*new_edge));
    new_edge->v2 = prerequisites[i][1];
    new_edge->next = adj_list[prerequisites[i][0]];
    adj_list[prerequisites[i][0]] = new_edge;
  }
  
  for (i = 0; i < prerequisitesSize; i++) {
    in_degrees[prerequisites[i][1]]++;
  }
  
  for (i = 0; i < numCourses; i++) {
    if (visit[i] == 2)
      continue;
    s_idx = 0;
    stack[s_idx++] = i;
    while (s_idx) {
      curr = stack[s_idx - 1];
      if (visit[curr] == 1) {
        s_idx--;
        visit[curr] = 2;
        continue;
      }
      visit[curr] = 1;
      runner = adj_list[curr];
      while (runner) {
        if (visit[runner->v2] == 1)
          return false;
        //not already visited
        if (visit[runner->v2] != 2)
          stack[s_idx++] = runner->v2;
        runner = runner->next;
      }
    }
  }
  return true;
}

Added later:

This is not always the case. In some cases, in DFS, you can just pop from the stack (like DFS). For instance, number-of-islands problem can be solved using that. 

31. For instance, you want to reverse each word in  a string. Here, you should iterate from 0 to strlen(s) + 1. If i-th character is a space or NULL, then reverse the string.

32. If you are asked need to reverse a string, note that, your pointer should be i = 0, j = strlen(s). Often I take j = strlen (s) + 1.

33. For instance, You need to remove leading and trailing spaces. You also need to remove extra spaces between words. you can do it by maintaining a state variable called ignore_space. Initially it should be true. If you get a character, make it false. Again if you get a space, make it true.

34. If you print each trhiplet of an array, it should be like:

  i : 0 to len - 3
    j : i + 1 to len - 2
      k : j + 1 to len - 1

Not, 

  i : 0 to len - 1
    j : i + 1 to len -1
      k : j + 1 to len - 1

34. isalpha() checks if a char is a-z A-Z

35. Sometiomes, a problem can be solve by using two pointers and swaping element... (for instance, Sort Array By Parity). But, the problem can be also solved by quicksort partition.

Quick sort partion does the same thing in an uniform way. It also uses two indices and a pivot (usually the last element). Surprisingly, the two indices, i = -1 and j = 0. Idea is we will iterate j: 0 to n-1. Everytime arr[j] < pivot, swap (arr[++i], arr[j++]). That is, i keeps track of the left most element to which a smaller element needs to be swapped to. Finally, swap (arr[++i], arr[pivot]).

In other word, partitioning is a single pointer approach. It iterates from the first element to the last but one element. During iteration, it keeps track of the index to which a smaller element should be swapped to (represented by i). 

For details, take a look at https://www.geeksforgeeks.org/quick-sort/ 

36. if (a & 1 == 0) will not work!!!!. It should be if ((a & 1) == 0)

37. isalpha() checks if a character is an alphabet

38. It is possible to use sizeof () to calculate the amount of memory a string is consuming. But, you may get wrong results sometimes. So, you strlen instead of sizeof () to calculate the memory size of a string.

https://stackoverflow.com/questions/18525272/getting-wrong-string-length

39. Sometimes you may want to implement a circular array (e.g. hit counter problem). Mapping an element to an index of an array can be tricky. For instance, you want to access i-th element (index starts from 1) where length of the array in len. You can do so by

idx = (i - 1) % len; Not idx = (i % len) - 1.

Also iterating circular array can be tricky. for instace, you want iterate from index "start" to "end".

It should be :

for (i = start; i != end; i = (i + 1) % len) {

}

Note how we are incrementing i.
Also note how we are checking if we reached to the end. Checking if i < len will not work because if start > end, then i needs to be increase to end, then become 0 and then reach the end.

Again, for instance, you have two index i and j. You want to check if (i == j - 1), i.e. if i is the preceding element of j. You cannot do it directly because arr[len-1] is the preceeding element of arr[len-1]. To check such case, you can do this:

if ((i + 1) % len == j)

Also note that, idx_new_elem > idx_last_inserted_elem + len. That is, you are rounding the whole array. So, you may want to store that last inserted element.

40. Don't update input parameters as local variable. Create your own. It is less error prone.

41. If you need to calculate sum or multiplication of int/float, check if you need "long long" (for int) or "double" (for float) to store it. Otherwise overflow happens. If you need long long or double, also change the expression to make sure that longlong or double is stored. For instance,

int a, b;
long long sum;

sum = (long long)a + b; 

42. To print long long, using %lld. To print unsigned long long, use %llu

43. In snake ladder problem, it will be easier to solve the problem by considering each cell a number rather than a row and column. This patterns hold for many cases. If you have a 2D array, think if you can treat each cell as number instead of row col.

Sometimes, number to row-column conversion can be simplified by using slightly differnet equation. For instance, you can do the following:

  row = num / 6;
  if (num % 6 == 0)
    row--;

This can be simplified to 

  row = (num - 1) / 6;

So, if you need a special condition, check if you can find a pattern where the speacial condition goes away.

Also note that you may need to revisit the equation later if the equation works for all the cases.

44. Sometimes, in DP, I make O(n^2) solution where I could make O(n) solution (for instance house robber 1 and 2). In DP, you should not need to look much further in the DP table. You should only need to look for few previous elements to calculate the new element. If you need to look all the previous elements, double check if you could formulate DP such that that is not needed.

Note that, there are two types of DP table we saw so far.

One DP table always stores the best solution so far. It calculates the next entry based on the best solution of the current entry.

Another DP table stores the best solution using the current node. In this case, to calculate the value of a new entry, we need to iterate all the previous entry to get the best solution.

45. Sometimes, a complex problem can be break into simpler problems. Then solve the simpler problem. For instance, break the circular array of house robber II problem into two linear arrays.


46. atoi () returns 0 if convertion is not sucessful. If it returns non-zero, then conversion was sucessfull. Note that we cannot convert "0" with atoi. We need to check that manually. Note that if you pass a string "2+1+3" to atoi(), it returns 2. So, don't use to check if a string is a number or not.

47. Sometimes, you need to find all possible cases of something. You won't need backtracking. But, you can use divide and conquar to break the problem into smaller problems. Then combine the results. You can implement that using recursion. For instance, different-ways-to-add-parentheses problem.

48. abs() returns absolute value. not mod(). sqrt() calculates square root, not sqart().

49. Sometimes, in DFS and BFS, we also need to store level in a separate array than stack/queue.

50. For instance, you are given a position of a knite in chess (horse). There are 8 possible next moves of the knite. You can find all the possible next move manually by add 1/2/-1/-2... But, better approach is store those numbers in an array and calculate the next index uniformly. Example:

int nm [8][2] = {{2, 1}, {2, -1}, {-2, 1}, {-2, -1}, {1, 2}, {1, -2}, {-1, 2}, {-1, -2}};

Then add the corresponding element.

51. Sometimes, you may tend to use dynamic array to implement the visit array of DFS or BFS. But, don't do that. It causes TLE (lookup in o(n)). Figure out a way to implement array, 2D array or hash to implement the visit array so that lookup in O(1).

52. BFS does not always need queue. You may need to use heap (priority queue) instead. Specially, we need to use heap in BFS in case of A* search. Note that, in A* search, each node will also have a heuristic value. The value is calculated based on two functions: 1) How far it is from start node 2) How far it is from the destination node.

We pick up the node with the lowest heuristic value from the heap.

Note that, the heuristic functiuon can be manhatan distance (abs(x1-x2) + abs (y1-y2)) or euclidian distance (sqrt (pow (x1-x2, 2) + pow (y1-y2, 2))).
Manhantan distance is preferable if we only are allowed to go vertically or horizontally. If we are allowed to go diagonally, euclidean distance is prefereable.

Note, the Dijekstra is a special case for A* search (and BFS). Here, heuristic function only contains the distance from the start node (does not contain distance from that node to end node). In Dijekstra, we can also use a heap to extract the node with lowest weight. 


53. Sometimes, the size of the visited array of BFS/DFS or the size of the stack and queue can be inferred from the constraint. For instance, in minimum-knight-moves problem, contraint is |x| + |y| <= 300. Here, x, y are the target coordinate of the knight. From the constraint, we can assume that the size of the visit array would 605 x 605 (one for initial point. 302 in each way).

54. Sometimes greedy solution may be tempting. For instance, coin change problem. However, with few counter example, you will notice that the greedy solution will not work. Next solution would be recursion to compute all possible situation. In that, try to write a mathemetical equation on paper. This really helps. Note that, the equation may need to find minimum/maximum of an expression for all inputs. The recursion generally works because it explores all possible solution. But, the recursive solutions are exponential. So, try to solve this using DP. If the problem follows principle of optimality (i.e. soution is subproblem will be there in larger problem), you can use DP using the recursive equation.
 
