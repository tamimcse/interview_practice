1. To include "match.h", need to use -lm to compile

2. In backtracking algorithms, the inner algorithm should not return anything. The inner algorithm should return the outout as input.

3. cmp in qsort():

int cmp (const void *a, const void *b)
{
  return *((int *)a) - *((int *)b);
}

3. qsort prototype: qsort(arr, len, sizeof(arr[0]), cmp);

4. When returning char *, note that char * should also include '\0'. So, when allocating it, allocate one character extra.

5. when assigning NULL to an element of char *, assign '\0' instead;

6. Note that, you need to include 'string.h' in order to use memcpy.

7. memcpy prototype: memcpy(void *dest, const void * src, size_t n);
   memset prototype: memset(void *str, int c, size_t n);

8. remember that there are sprintf () and scanf ().

9. ASCII table has 256 characxters

9. When dealing with equation with index, double check if your equation needs "- 1".

10. Remember what palindrome and anagram means. Two strings are anagrams if their character count of each character is same for the two string. For instance, eat, ate and tea are anagram. 

11. *returnColumnSizes[i] is not right . It should be (*returnColumnSizes)[i].

12. Adjacency matrix may look easier than adjacency list, but they are really not. So, don't try to use adjacency matrix because it's easier. Besides, adjacency matrix requires looping through each element to the matrix row which cause to exceed time limit for large matrix.

13. Sometimes, a problem can be solved using graph. But, it can be solved not using graph and the version is more efficient. 

14. Sometimes, a problem can be solved using graph. and should be solved using graph. But, not really creating graph data structure. Remember the "word search" problem. Apply DFS without creating the graph.

15. Instead of checking col < num_col - 1, check if col + 1 < num_col.

16. If you need visit array for a 2D array (each element of the array is a node), create a 2D visit array, instead of a single array representing a 2D array. It produces cleaner code.

17. Think in terms of array length instead of index. This results clear code and easy to think of.

18. Instead of checking num_chars_grouped <= len - 2, check num_chars_grouped + 2 <= len.

19. For instance, you have two characters containing digits. Need to check if they corresponds to 1-26. You can check the first character and the  check if the second characters are within certain range. Instead, convert the string to its numerical value.

20. Sometimes, a problem may look like backtracking. Then look carefully if there is overlapping substructure. If there is, they can be optimized by memorization or even better can be implemented by DP. 

21. We can create zig zag pattern using two stacks.

22. Check if you can use a fixed number for stack or queue. If yes, alllocate it statically instead of dynamicly.

 


